# Plugin H264 设计规范文档

## 1. 项目概述

### 1.1 项目目标
开发一个基于H.264编码的Solar2D视频播放插件，替代现有的Theora方案，提供更好的压缩率和格式兼容性。

### 1.2 设计原则
- **API兼容性**: 保持与现有plugin_movie完全兼容的Lua API
- **最小库体积**: 控制总库增量在3MB以内
- **跨平台一致**: 所有平台使用相同代码实现
- **性能优先**: 提供比Theora更好的解码性能

## 2. 架构设计

### 2.1 整体架构

```
Plugin H264 架构:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Lua接口层     │    │    C++核心层     │    │   第三方库层    │
├─────────────────┤    ├──────────────────┤    ├─────────────────┤
│ plugin_h264.lua │ ←→ │ PluginH264.cpp   │ ←→ │ OpenH264        │
│ (兼容API)       │    │ - H264Movie结构  │    │ - H264解码      │
│ - newMovieTexture│    │ - MP4解封装      │    │ MP4解封装库     │
│ - newMovieRect   │    │ - AAC音频解码    │    │ - 容器处理      │
│ - newMovieLoop   │    │ - Solar2D纹理    │    │ AAC解码库       │
│                 │    │ - OpenAL音频     │    │ - 音频解码      │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

### 2.2 模块划分

```
shared/
├── PluginH264.h/cpp           # 主插件接口
├── H264Decoder.h/cpp          # H264视频解码器封装
├── MP4Demuxer.h/cpp           # MP4容器解封装
├── AACDecoder.h/cpp           # AAC音频解码器封装
├── AudioVideoSync.h/cpp       # 音视频同步管理
├── plugin_h264.lua            # Lua接口层
└── generated/
    └── plugin_h264.c          # 自动生成的绑定代码
```

## 3. 核心数据结构设计

### 3.1 H264Movie结构体

```cpp
struct H264Movie {
    // 解码器实例
    ISVCDecoder* h264_decoder;      // OpenH264解码器
    void* mp4_demuxer;              // MP4解封装器
    void* aac_decoder;              // AAC音频解码器
    
    // 当前帧数据
    const H264VideoFrame* video;    // 当前视频帧
    const AACPacket* audio;         // 当前音频包
    
    // 播放状态
    bool playing;
    bool stopped;
    bool initialized;
    bool has_audio;
    bool has_video;
    
    // 时间同步
    double video_time;              // 视频时间戳(秒)
    double audio_time;              // 音频时间戳(秒)
    double start_time;              // 播放开始时间
    unsigned int frame_duration;    // 帧间隔(毫秒)
    
    // 视频信息
    int width;
    int height;
    int fps;
    unsigned char* frame_buffer;    // YUV->RGB转换缓冲区
    
    // OpenAL音频
    ALuint source;
    ALenum audio_format;
    ALuint buffers[NUM_BUFFERS];    // 复用现有缓冲区数量
    int sample_rate;
    int channels;
    
    // 资源管理
    bool need_cleanup;
    unsigned char empty_pixel[4];   // 空像素数据
};
```

### 3.2 视频帧结构

```cpp
struct H264VideoFrame {
    double timestamp;               // 时间戳(秒)
    int width;
    int height;
    PixelFormat format;            // YUV420P -> RGBA
    unsigned char* pixels;         // RGB/RGBA像素数据
    size_t pixel_size;
    struct H264VideoFrame* next;   // 链表结构
};
```

### 3.3 音频包结构

```cpp
struct AACPacket {
    double timestamp;              // 时间戳(秒)
    int channels;                  // 声道数
    int sample_rate;               // 采样率
    int frames;                    // 样本帧数
    float* samples;                // PCM样本数据
    size_t sample_size;
    struct AACPacket* next;
};
```

## 4. 关键接口设计

### 4.1 C++核心接口

```cpp
// PluginH264.cpp - 主要接口函数
class PluginH264 {
public:
    // Lua绑定接口
    static int luaopen_plugin_h264(lua_State *L);
    static int newMovieTexture(lua_State *L);
    
    // 播放控制
    static int update(lua_State *L);
    static int play(lua_State *L);
    static int pause(lua_State *L);
    static int stop(lua_State *L);
    
    // 状态查询
    static int isActive(lua_State *L, void *context);
    static int isPlaying(lua_State *L, void *context);
    static int currentTime(lua_State *L, void *context);
    
    // Solar2D纹理回调
    static unsigned int GetWidth(void *context);
    static unsigned int GetHeight(void *context);
    static const void* GetImage(void *context);
    
private:
    // 内部实现
    static bool initializeMovie(H264Movie* movie, const char* filename);
    static void updateVideoFrame(H264Movie* movie, double delta_time);
    static void updateAudioStream(H264Movie* movie);
    static void cleanupMovie(H264Movie* movie);
};
```

### 4.2 H264解码器接口

```cpp
// H264Decoder.h
class H264Decoder {
public:
    H264Decoder();
    ~H264Decoder();
    
    bool initialize(int width, int height);
    bool decode(const uint8_t* h264_data, size_t data_size, H264VideoFrame& frame);
    void reset();
    bool isInitialized() const { return decoder != nullptr; }
    
private:
    ISVCDecoder* decoder;
    SBufferInfo buffer_info;
    unsigned char* yuv_buffer[3];  // Y, U, V平面
    unsigned char* rgb_buffer;     // RGB输出缓冲区
    SwsContext* sws_context;       // YUV->RGB转换上下文
    
    bool initializeConverter(int width, int height);
    void convertYUVToRGB(const SBufferInfo& buffer_info, unsigned char* rgb_output);
};
```

### 4.3 MP4解封装器接口

```cpp
// MP4Demuxer.h  
class MP4Demuxer {
public:
    MP4Demuxer();
    ~MP4Demuxer();
    
    bool open(const std::string& filename);
    bool hasVideoTrack() const { return video_track_id >= 0; }
    bool hasAudioTrack() const { return audio_track_id >= 0; }
    
    // 获取媒体信息
    int getVideoWidth() const;
    int getVideoHeight() const;
    double getVideoFPS() const;
    int getAudioSampleRate() const;
    int getAudioChannels() const;
    
    // 读取数据包
    bool readVideoPacket(uint8_t** data, size_t* size, double* timestamp);
    bool readAudioPacket(uint8_t** data, size_t* size, double* timestamp);
    
    // 定位控制
    bool seek(double timestamp);
    bool isEOF() const;
    
private:
    void* mp4_handle;              // MP4文件句柄
    int video_track_id;
    int audio_track_id;
    double duration;
    bool is_open;
    
    bool findTracks();
    bool parseVideoTrack();
    bool parseAudioTrack();
};
```

### 4.4 AAC解码器接口

```cpp
// AACDecoder.h
class AACDecoder {
public:
    AACDecoder();
    ~AACDecoder();
    
    bool initialize(int sample_rate, int channels);
    bool decode(const uint8_t* aac_data, size_t data_size, AACPacket& packet);
    void reset();
    
private:
    void* aac_handle;              // AAC解码器句柄
    int output_sample_rate;
    int output_channels;
    float* pcm_buffer;             // PCM输出缓冲区
    size_t buffer_size;
    
    bool initializeFAAD();
};
```

## 5. Lua API设计

### 5.1 保持兼容的API

```lua
-- plugin_h264.lua (与plugin_movie.lua完全兼容)
local lib = Library:new({
    name = 'plugin.h264',          -- 修改插件名
    publisherId = 'com.ansh3ll'
})

-- 核心API保持不变
function lib.newMovieTexture(opts)
    -- 实现与原版完全相同
    local path = system.pathForFile(opts.filename, opts.baseDir or system.ResourceDirectory)
    local source = audio.getSourceFromChannel(opts.channel or audio.findFreeChannel())
    return lib._newMovieTexture(path, source, display.fps)
end

function lib.newMovieRect(opts)
    -- 实现逻辑完全相同，只是底层调用不同
    -- ... (保持现有实现)
end

function lib.newMovieLoop(opts)
    -- 实现逻辑完全相同
    -- ... (保持现有实现)
end
```

### 5.2 扩展API(可选)

```lua
-- 新增H.264特有功能
function lib.getVideoInfo(filename)
    return {
        width = 1920,
        height = 1080,
        fps = 30,
        duration = 120.5,        -- 秒
        has_audio = true,
        codec = "H.264",
        audio_codec = "AAC"
    }
end

function lib.setDecodingOptions(opts)
    -- H.264解码选项
    opts = opts or {}
    opts.threads = opts.threads or 1            -- 解码线程数
    opts.skip_frame = opts.skip_frame or false  -- 跳帧加速
    opts.low_delay = opts.low_delay or false    -- 低延迟模式
end
```

## 6. 构建系统设计

### 6.1 CMake配置

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.19)
project(plugin_h264)

# 第三方库配置
set(OPENH264_ROOT ${CMAKE_SOURCE_DIR}/third_party/openh264)
set(MP4_PARSER_ROOT ${CMAKE_SOURCE_DIR}/third_party/mp4parser)
set(AAC_DECODER_ROOT ${CMAKE_SOURCE_DIR}/third_party/faad2)

# 包含路径
include_directories(
    ${OPENH264_ROOT}/include
    ${MP4_PARSER_ROOT}/include  
    ${AAC_DECODER_ROOT}/include
    shared/include
)

# 源文件
set(SOURCES
    shared/PluginH264.cpp
    shared/H264Decoder.cpp
    shared/MP4Demuxer.cpp
    shared/AACDecoder.cpp
    shared/AudioVideoSync.cpp
    shared/generated/plugin_h264.c
)

# 库依赖
target_link_libraries(plugin_h264
    ${OPENH264_ROOT}/lib/libopenh264.a
    ${MP4_PARSER_ROOT}/lib/libmp4parser.a
    ${AAC_DECODER_ROOT}/lib/libfaad.a
)
```

### 6.2 平台特定配置

```bash
# Android (android/jni/Android.mk)
LOCAL_MODULE := plugin.h264
LOCAL_STATIC_LIBRARIES := openh264_static mp4parser_static faad2_static
LOCAL_LDLIBS := -llog -landroid

# iOS (ios/Plugin.xcodeproj)
# 添加OpenH264.framework, MP4Parser.framework, FAAD2.framework

# Windows (win32/Plugin.vcxproj)
# 链接openh264.lib, mp4parser.lib, faad2.lib

# macOS (mac/Plugin.xcodeproj) 
# 类似iOS配置
```

## 7. 性能优化策略

### 7.1 内存管理优化

```cpp
class FramePool {
    static const int POOL_SIZE = 8;
    H264VideoFrame frame_pool[POOL_SIZE];
    bool frame_used[POOL_SIZE];
    
public:
    H264VideoFrame* acquireFrame();
    void releaseFrame(H264VideoFrame* frame);
    void resetPool();
};

class AudioBufferPool {
    static const int BUFFER_SIZE = 16;
    AACPacket audio_pool[BUFFER_SIZE];
    bool buffer_used[BUFFER_SIZE];
    
public:
    AACPacket* acquireBuffer();
    void releaseBuffer(AACPacket* packet);
};
```

### 7.2 多线程策略

```cpp
// 简化的单线程设计 (第一版)
class H264Movie {
    // 主线程处理所有解码
    bool decodeNextFrame();
    bool decodeNextAudio();
    void synchronizeAV();
};

// 未来扩展的多线程设计
class H264MovieThreaded {
    std::thread video_thread;     // 视频解码线程
    std::thread audio_thread;     // 音频解码线程
    ThreadSafeQueue<H264VideoFrame> video_queue;
    ThreadSafeQueue<AACPacket> audio_queue;
};
```

### 7.3 缓存策略

```cpp
struct DecodingCache {
    static const int VIDEO_CACHE_SIZE = 3;  // 预解码3帧
    static const int AUDIO_CACHE_SIZE = 10; // 预解码10个音频包
    
    H264VideoFrame video_cache[VIDEO_CACHE_SIZE];
    AACPacket audio_cache[AUDIO_CACHE_SIZE];
    
    int video_read_pos;
    int video_write_pos;
    int audio_read_pos;
    int audio_write_pos;
};
```

## 8. 错误处理设计

### 8.1 错误代码定义

```cpp
enum H264Error {
    H264_OK = 0,
    H264_ERROR_FILE_NOT_FOUND = -1,
    H264_ERROR_INVALID_FORMAT = -2,
    H264_ERROR_DECODER_INIT_FAILED = -3,
    H264_ERROR_DECODE_FAILED = -4,
    H264_ERROR_OUT_OF_MEMORY = -5,
    H264_ERROR_AUDIO_INIT_FAILED = -6,
    H264_ERROR_SYNC_FAILED = -7
};
```

### 8.2 错误处理机制

```cpp
class ErrorHandler {
public:
    static void logError(H264Error error, const char* details);
    static void reportToLua(lua_State* L, H264Error error);
    static bool isRecoverable(H264Error error);
};

// 在关键函数中使用
bool H264Decoder::decode(const uint8_t* data, size_t size, H264VideoFrame& frame) {
    if (!decoder) {
        ErrorHandler::logError(H264_ERROR_DECODER_INIT_FAILED, "Decoder not initialized");
        return false;
    }
    
    int ret = (*decoder)->DecodeFrame2(decoder, data, size, frame.pixels, &buffer_info);
    if (ret != dsErrorFree) {
        ErrorHandler::logError(H264_ERROR_DECODE_FAILED, "H264 decode failed");
        return false;
    }
    
    return true;
}
```

## 9. 测试策略

### 9.1 单元测试

```cpp
// tests/test_h264_decoder.cpp
TEST(H264Decoder, BasicDecoding) {
    H264Decoder decoder;
    ASSERT_TRUE(decoder.initialize(1920, 1080));
    
    // 加载测试H264数据
    std::vector<uint8_t> h264_data = loadTestData("test.h264");
    
    H264VideoFrame frame;
    ASSERT_TRUE(decoder.decode(h264_data.data(), h264_data.size(), frame));
    ASSERT_EQ(frame.width, 1920);
    ASSERT_EQ(frame.height, 1080);
}

TEST(MP4Demuxer, FileOpening) {
    MP4Demuxer demuxer;
    ASSERT_TRUE(demuxer.open("test.mp4"));
    ASSERT_TRUE(demuxer.hasVideoTrack());
    ASSERT_TRUE(demuxer.hasAudioTrack());
}
```

### 9.2 集成测试

```lua
-- tests/test_integration.lua
local h264 = require('plugin.h264')

-- 基本功能测试
local texture = h264.newMovieTexture({
    filename = "test.mp4"
})
assert(texture ~= nil)
texture:play()

-- API兼容性测试
local rect = h264.newMovieRect({
    x = 100, y = 100,
    width = 320, height = 240,
    filename = "test.mp4"
})
rect.play()
```

### 9.3 性能基准测试

```cpp
// benchmarks/decode_performance.cpp
void BenchmarkH264Decode() {
    H264Decoder decoder;
    decoder.initialize(1920, 1080);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < 1000; ++i) {
        H264VideoFrame frame;
        decoder.decode(test_data, test_size, frame);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "1000 frames decoded in " << duration.count() << "ms" << std::endl;
}
```

## 10. 部署和发布

### 10.1 发布包结构

```
plugin_h264_v1.0/
├── shared/
│   ├── plugin_h264.lua
│   └── libs/
│       ├── android/
│       │   ├── arm64-v8a/libplugin.h264.so
│       │   ├── armeabi-v7a/libplugin.h264.so
│       │   └── x86_64/libplugin.h264.so
│       ├── ios/
│       │   └── libplugin.h264.a
│       ├── win32/
│       │   └── plugin.h264.dll
│       └── macos/
│           └── libplugin.h264.dylib
├── docs/
│   ├── API_Reference.md
│   ├── Migration_Guide.md
│   └── Performance_Guide.md
└── examples/
    ├── basic_playback.lua
    ├── loop_video.lua
    └── custom_controls.lua
```

### 10.2 向后兼容策略

```lua
-- 迁移脚本 migrate_to_h264.lua
local function migrateProject()
    -- 1. 替换require语句
    local oldCode = 'require("plugin.movie")'
    local newCode = 'require("plugin.h264")'
    
    -- 2. 更新build.settings
    local oldPlugin = '["plugin.movie"] = { publisherId = "com.ansh3ll" }'
    local newPlugin = '["plugin.h264"] = { publisherId = "com.ansh3ll" }'
    
    print("Migration completed. All APIs remain compatible.")
end
```

## 11. 项目里程碑

### 11.1 开发阶段

```
Phase 1: 核心解码器实现 (2-3周)
├── OpenH264解码器封装
├── MP4解封装器实现
├── AAC音频解码器
└── 基本播放功能

Phase 2: Solar2D集成 (2-3周)  
├── Lua API适配
├── 纹理系统集成
├── OpenAL音频集成
└── 播放控制实现

Phase 3: 优化和测试 (2-3周)
├── 性能优化
├── 内存泄漏测试
├── 跨平台测试
└── API兼容性验证

Phase 4: 文档和发布 (1-2周)
├── API文档完善
├── 示例代码开发
├── 迁移指南编写
└── 正式版发布
```

### 11.2 验收标准

```
功能验收:
☐ 支持H.264/AAC的MP4文件播放
☐ 完全兼容现有plugin_movie API
☐ 支持所有目标平台(Android/iOS/Windows/macOS)
☐ 播放控制功能正常(play/pause/stop/seek)
☐ 音视频同步精确度<40ms

性能验收:
☐ 1080p@30fps流畅播放
☐ 内存使用不超过现有方案150%
☐ 库文件大小<3MB
☐ 冷启动时间<500ms

质量验收:
☐ 无内存泄漏
☐ 无崩溃bug
☐ 错误处理完善
☐ 代码覆盖率>80%
```

这个设计文档为Plugin H264的开发提供了完整的技术规范和实现指导。