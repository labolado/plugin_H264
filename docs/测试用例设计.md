# Plugin H264 æµ‹è¯•ç”¨ä¾‹è®¾è®¡
*åŸºäºæŠ€æœ¯éªŒè¯ç»“æœçš„å…¨é¢æµ‹è¯•ç”¨ä¾‹è§„èŒƒ*

## 1. æµ‹è¯•ç”¨ä¾‹æ¦‚è¿°

### 1.1 è®¾è®¡åŸåˆ™
- **éªŒè¯é©±åŠ¨**: æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹åŸºäº2025å¹´8æœˆ29æ—¥çš„æŠ€æœ¯éªŒè¯ç»“æœ
- **å¯é‡ç°æ€§**: æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹éƒ½æœ‰æ˜ç¡®çš„ç¯å¢ƒè¦æ±‚å’Œé¢„æœŸç»“æœ
- **å¯è¿½æº¯æ€§**: æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹éƒ½å¯è¿½æº¯åˆ°å…·ä½“çš„éœ€æ±‚å’ŒéªŒæ”¶æ ‡å‡†
- **è‡ªåŠ¨åŒ–å‹å¥½**: ä¼˜å…ˆè®¾è®¡å¯è‡ªåŠ¨åŒ–æ‰§è¡Œçš„æµ‹è¯•ç”¨ä¾‹

### 1.2 æµ‹è¯•ç”¨ä¾‹åˆ†ç±»
```
æµ‹è¯•ç”¨ä¾‹åˆ†ç±»ä½“ç³»:
â”œâ”€â”€ åŠŸèƒ½æµ‹è¯•ç”¨ä¾‹ (60%)
â”‚   â”œâ”€â”€ æ ¸å¿ƒè§£ç åŠŸèƒ½
â”‚   â”œâ”€â”€ APIå…¼å®¹æ€§æµ‹è¯•  
â”‚   â”œâ”€â”€ é”™è¯¯å¤„ç†æµ‹è¯•
â”‚   â””â”€â”€ è¾¹ç•Œæ¡ä»¶æµ‹è¯•
â”œâ”€â”€ æ€§èƒ½æµ‹è¯•ç”¨ä¾‹ (20%)
â”‚   â”œâ”€â”€ è§£ç æ€§èƒ½æµ‹è¯•
â”‚   â”œâ”€â”€ å†…å­˜ä½¿ç”¨æµ‹è¯•
â”‚   â””â”€â”€ å¹¶å‘æ€§èƒ½æµ‹è¯•
â”œâ”€â”€ å…¼å®¹æ€§æµ‹è¯•ç”¨ä¾‹ (15%)
â”‚   â”œâ”€â”€ å¹³å°å…¼å®¹æ€§
â”‚   â”œâ”€â”€ æ–‡ä»¶æ ¼å¼å…¼å®¹æ€§
â”‚   â””â”€â”€ Solar2Dç‰ˆæœ¬å…¼å®¹æ€§
â””â”€â”€ å¯é æ€§æµ‹è¯•ç”¨ä¾‹ (5%)
    â”œâ”€â”€ é•¿æ—¶é—´è¿è¡Œæµ‹è¯•
    â”œâ”€â”€ å‹åŠ›æµ‹è¯•
    â””â”€â”€ å¼‚å¸¸æ¢å¤æµ‹è¯•
```

### 1.3 æµ‹è¯•ç”¨ä¾‹æ ‡è¯†è§„èŒƒ
```
æ ¼å¼: [æ¨¡å—]_[ç±»å‹]_[ç¼–å·]_[æè¿°]
ç¤ºä¾‹: H264_FUNC_001_BasicDecoding
     AAC_PERF_001_DecodingSpeed
     MP4_COMPAT_001_StandardFiles
```

## 2. åŠŸèƒ½æµ‹è¯•ç”¨ä¾‹è®¾è®¡

### 2.1 OpenH264è§£ç å™¨æµ‹è¯•ç”¨ä¾‹

#### 2.1.1 åŸºç¡€åŠŸèƒ½æµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: H264_FUNC_001_DecoderInitialization
åˆ†ç±»: åŠŸèƒ½æµ‹è¯• > æ ¸å¿ƒè§£ç åŠŸèƒ½
ä¼˜å…ˆçº§: P0 (å…³é”®)
æè¿°: éªŒè¯OpenH264è§£ç å™¨æ­£ç¡®åˆå§‹åŒ–

å‰ç½®æ¡ä»¶:
  - OpenH264åº“ç‰ˆæœ¬ 2.6.0 å·²æ­£ç¡®é“¾æ¥
  - æµ‹è¯•ç¯å¢ƒæ»¡è¶³æœ€ä½è¦æ±‚

æµ‹è¯•æ­¥éª¤:
  1. åˆ›å»ºH264Decoderå®ä¾‹
  2. è°ƒç”¨initialize()æ–¹æ³•
  3. éªŒè¯åˆå§‹åŒ–è¿”å›ç»“æœ
  4. æ£€æŸ¥è§£ç å™¨å†…éƒ¨çŠ¶æ€

é¢„æœŸç»“æœ:
  - initialize()è¿”å›true
  - WelsCreateDecoder()è¿”å›0 (æˆåŠŸ)
  - decoder_æŒ‡é’ˆéç©º
  - hasError()è¿”å›false

æµ‹è¯•æ•°æ®: æ— éœ€æµ‹è¯•æ•°æ®
è‡ªåŠ¨åŒ–: æ˜¯
åŸºäºéªŒè¯: OpenH264 2.6.0 APIéªŒè¯ç»“æœ

å®ç°ç¤ºä¾‹:
```cpp
TEST_F(H264DecoderTest, DecoderInitialization) {
    auto decoder = std::make_unique<H264Decoder>();
    
    // åŸºäºéªŒè¯ç»“æœçš„åˆå§‹åŒ–æµ‹è¯•
    EXPECT_TRUE(decoder->initialize());
    EXPECT_FALSE(decoder->hasError());
    EXPECT_NE(decoder->getDecoderHandle(), nullptr);
    
    // éªŒè¯è§£ç å™¨é€‰é¡¹è®¾ç½® (åŸºäºéªŒè¯å‘ç°çš„æ­£ç¡®API)
    auto options = decoder->getDecoderOptions();
    EXPECT_TRUE(options.error_concealment_enabled);
}
```
```

#### 2.1.2 é”™è¯¯å¤„ç†æµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: H264_FUNC_002_ErrorHandling
åˆ†ç±»: åŠŸèƒ½æµ‹è¯• > é”™è¯¯å¤„ç†æµ‹è¯•
ä¼˜å…ˆçº§: P0 (å…³é”®)
æè¿°: éªŒè¯è§£ç å™¨æ­£ç¡®å¤„ç†å„ç§é”™è¯¯æƒ…å†µ

å‰ç½®æ¡ä»¶:
  - H264è§£ç å™¨å·²æ­£ç¡®åˆå§‹åŒ–
  - å‡†å¤‡å„ç§å¼‚å¸¸è¾“å…¥æ•°æ®

æµ‹è¯•æ­¥éª¤:
  1. æµ‹è¯•ç©ºæŒ‡é’ˆè¾“å…¥å¤„ç†
  2. æµ‹è¯•æ— æ•ˆæ•°æ®è¾“å…¥å¤„ç†  
  3. æµ‹è¯•é”™è¯¯å‚æ•°è®¾ç½®å¤„ç†
  4. éªŒè¯é”™è¯¯ç å’Œé”™è¯¯ä¿¡æ¯

å­æµ‹è¯•ç”¨ä¾‹:
  - H264_FUNC_002a_NullPointerInput
  - H264_FUNC_002b_InvalidDataInput
  - H264_FUNC_002c_WrongParameterSetting

é¢„æœŸç»“æœ:
  - ç©ºæŒ‡é’ˆè¾“å…¥ï¼šgracefullyå¤„ç†ï¼Œä¸å´©æºƒ
  - æ— æ•ˆæ•°æ®ï¼šè¿”å›ç›¸åº”é”™è¯¯ç ï¼Œé”™è¯¯ä¿¡æ¯å‡†ç¡®
  - é”™è¯¯å‚æ•°ï¼šåŸºäºéªŒè¯ç»“æœçš„é”™è¯¯å¤„ç†è¡Œä¸º

æµ‹è¯•æ•°æ®:
  - corrupted_h264_data.bin (æŸåçš„H.264æ•°æ®)
  - invalid_parameters.json (æ— æ•ˆå‚æ•°é›†åˆ)

åŸºäºéªŒè¯: éªŒè¯è¿‡ç¨‹ä¸­å‘ç°çš„é”™è¯¯å¤„ç†æœºåˆ¶

å®ç°ç¤ºä¾‹:
```cpp
TEST_F(H264DecoderTest, ErrorHandling_NullPointer) {
    auto decoder = std::make_unique<H264Decoder>();
    decoder->initialize();
    
    uint8_t* output_buffer = nullptr;
    
    // åŸºäºéªŒè¯çš„é”™è¯¯å¤„ç†è¡Œä¸º
    bool result = decoder->decode(nullptr, 0, &output_buffer);
    EXPECT_FALSE(result);
    EXPECT_TRUE(decoder->hasError());
    
    std::string error_msg = decoder->getLastError();
    EXPECT_THAT(error_msg, ::testing::HasSubstr("Invalid input"));
}
```
```

#### 2.1.3 è§£ç è´¨é‡æµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: H264_FUNC_003_DecodingAccuracy
åˆ†ç±»: åŠŸèƒ½æµ‹è¯• > è§£ç è´¨é‡æµ‹è¯•
ä¼˜å…ˆçº§: P1 (é‡è¦)
æè¿°: éªŒè¯H.264è§£ç è¾“å‡ºçš„æ­£ç¡®æ€§å’Œè´¨é‡

å‰ç½®æ¡ä»¶:
  - H264è§£ç å™¨å·²åˆå§‹åŒ–
  - å‡†å¤‡æ ‡å‡†æµ‹è¯•è§†é¢‘æ–‡ä»¶
  - å‡†å¤‡å‚è€ƒYUVæ•°æ®

æµ‹è¯•æ­¥éª¤:
  1. è§£ç æ ‡å‡†æµ‹è¯•åºåˆ—
  2. å°†è¾“å‡ºYUVä¸å‚è€ƒæ•°æ®æ¯”è¾ƒ
  3. è®¡ç®—è´¨é‡æŒ‡æ ‡ (PSNR/SSIM)
  4. éªŒè¯ä¸åŒæ¡£æ¬¡çš„è§£ç ç²¾åº¦

æµ‹è¯•æ•°æ®:
  - h264_baseline_foreman_cif.264 + reference_yuv420.yuv
  - h264_main_akiyo_qcif.264 + reference_yuv420.yuv
  - h264_high_container_720p.264 + reference_yuv420.yuv

é¢„æœŸç»“æœ:
  - Baselineæ¡£æ¬¡: PSNR â‰¥ 35dB
  - Mainæ¡£æ¬¡: PSNR â‰¥ 35dB  
  - Highæ¡£æ¬¡: PSNR â‰¥ 35dB
  - æ— æ˜æ˜¾è§†è§‰ä¼ªå½±

åŸºäºéªŒè¯: è§£ç å™¨åŠŸèƒ½éªŒè¯ä¸­ç¡®è®¤çš„è´¨é‡åŸºçº¿

å®ç°ç¤ºä¾‹:
```cpp
TEST_F(H264DecoderTest, DecodingAccuracy_BaselineProfile) {
    auto decoder = std::make_unique<H264Decoder>();
    decoder->initialize();
    
    // åŠ è½½æµ‹è¯•æ•°æ®
    auto h264_data = loadTestFile("h264_baseline_foreman_cif.264");
    auto reference_yuv = loadReferenceYUV("reference_foreman_cif.yuv");
    
    std::vector<uint8_t> decoded_yuv;
    bool success = decoder->decodeSequence(h264_data, decoded_yuv);
    
    ASSERT_TRUE(success);
    ASSERT_EQ(decoded_yuv.size(), reference_yuv.size());
    
    // è®¡ç®—PSNR (åŸºäºéªŒè¯çš„è´¨é‡æ ‡å‡†)
    double psnr = calculatePSNR(decoded_yuv.data(), reference_yuv.data(), 
                                decoded_yuv.size());
    EXPECT_GE(psnr, 35.0);  // åŸºäºéªŒè¯ç¡®å®šçš„è´¨é‡é˜ˆå€¼
}
```
```

### 2.2 FDK-AACè§£ç å™¨æµ‹è¯•ç”¨ä¾‹

#### 2.2.1 å¤šå£°é“è§£ç æµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: AAC_FUNC_001_MultiChannelDecoding
åˆ†ç±»: åŠŸèƒ½æµ‹è¯• > æ ¸å¿ƒè§£ç åŠŸèƒ½
ä¼˜å…ˆçº§: P0 (å…³é”®)
æè¿°: éªŒè¯FDK-AACè§£ç å™¨æ”¯æŒå¤šç§å£°é“é…ç½®

å‰ç½®æ¡ä»¶:
  - FDK-AACè§£ç å™¨ 2.0.3 å·²åˆå§‹åŒ–
  - å‡†å¤‡ä¸åŒå£°é“é…ç½®çš„AACæµ‹è¯•æ–‡ä»¶

æµ‹è¯•æ­¥éª¤:
  1. æµ‹è¯•ç«‹ä½“å£°AACè§£ç 
  2. æµ‹è¯•5.1ç¯ç»•å£°AACè§£ç 
  3. æµ‹è¯•7.1ç¯ç»•å£°AACè§£ç 
  4. éªŒè¯è¾“å‡ºPCMæ•°æ®æ ¼å¼

å­æµ‹è¯•ç”¨ä¾‹:
  - AAC_FUNC_001a_StereoDecoding
  - AAC_FUNC_001b_5_1_SurroundDecoding  
  - AAC_FUNC_001c_7_1_SurroundDecoding

æµ‹è¯•æ•°æ®:
  - aac_stereo_48khz_128kbps.aac
  - aac_5_1_surround_48khz_448kbps.aac
  - aac_7_1_surround_48khz_640kbps.aac

é¢„æœŸç»“æœ:
  - ç«‹ä½“å£°: 2å£°é“, 48kHz, 16ä½PCM
  - 5.1å£°é“: 6å£°é“, 48kHz, 16ä½PCM
  - 7.1å£°é“: 8å£°é“, 48kHz, 16ä½PCM
  - éŸ³é¢‘è´¨é‡æ— æ˜æ˜¾å¤±çœŸ

åŸºäºéªŒè¯: FDK-AACå¤šå£°é“è§£ç åŠŸèƒ½éªŒè¯

å®ç°ç¤ºä¾‹:
```cpp
TEST_F(AACDecoderTest, MultiChannelDecoding_Stereo) {
    auto decoder = std::make_unique<AACDecoder>();
    ASSERT_TRUE(decoder->initialize());
    
    // åŸºäºéªŒè¯çš„ç«‹ä½“å£°æµ‹è¯•
    auto aac_data = loadTestFile("aac_stereo_48khz_128kbps.aac");
    std::vector<int16_t> pcm_output;
    
    bool success = decoder->decodeFrame(aac_data.data(), aac_data.size(), pcm_output);
    ASSERT_TRUE(success);
    
    // éªŒè¯è¾“å‡ºæ ¼å¼ (åŸºäºéªŒè¯ç»“æœ)
    EXPECT_EQ(decoder->getChannelCount(), 2);
    EXPECT_EQ(decoder->getSampleRate(), 48000);
    EXPECT_EQ(decoder->getBitsPerSample(), 16);
    
    // éªŒè¯PCMæ•°æ®æœ‰æ•ˆæ€§
    EXPECT_GT(pcm_output.size(), 0);
    EXPECT_EQ(pcm_output.size() % 2, 0);  // ç«‹ä½“å£°ï¼Œæ ·æœ¬æ•°åº”ä¸ºå¶æ•°
}
```
```

#### 2.2.2 è®¸å¯è¯åˆè§„éªŒè¯æµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: AAC_FUNC_002_LicenseCompliance
åˆ†ç±»: åŠŸèƒ½æµ‹è¯• > è®¸å¯è¯åˆè§„æµ‹è¯•
ä¼˜å…ˆçº§: P1 (é‡è¦)
æè¿°: éªŒè¯FDK-AACä½¿ç”¨ç¬¦åˆè®¸å¯è¯è¦æ±‚

å‰ç½®æ¡ä»¶:
  - FDK-AACåº“å·²æ­£ç¡®é›†æˆ
  - è®¸å¯è¯æ–‡æœ¬å·²åŒ…å«åœ¨é¡¹ç›®ä¸­

æµ‹è¯•æ­¥éª¤:
  1. éªŒè¯åº“ç‰ˆæœ¬ä¿¡æ¯
  2. æ£€æŸ¥ç‰ˆæƒå£°æ˜å­˜åœ¨
  3. éªŒè¯è®¸å¯è¯æ–‡æœ¬å®Œæ•´æ€§
  4. æ£€æŸ¥æºç åˆ†å‘å‡†å¤‡æƒ…å†µ

æµ‹è¯•å†…å®¹:
  - æ£€æŸ¥LIB_INFOç»“æ„ä½“ä¿¡æ¯
  - éªŒè¯Fraunhoferç‰ˆæƒå£°æ˜
  - ç¡®è®¤è®¸å¯è¯æ–‡ä»¶å­˜åœ¨
  - éªŒè¯å•†ä¸šä½¿ç”¨å£°æ˜

é¢„æœŸç»“æœ:
  - ç‰ˆæœ¬ä¿¡æ¯æ˜¾ç¤º "FDK AAC Codec Library for Android"
  - ç‰ˆæƒå£°æ˜åŒ…å« "Fraunhofer-Gesellschaft"
  - è®¸å¯è¯æ–‡ä»¶å®Œæ•´ä¸”å¯è¯»
  - å•†ä¸šä½¿ç”¨æƒé™æ˜ç¡®

åŸºäºéªŒè¯: è®¸å¯è¯åˆè§„æ€§éªŒè¯ç»“æœ

å®ç°ç¤ºä¾‹:
```cpp
TEST_F(AACDecoderTest, LicenseCompliance_VersionInfo) {
    auto decoder = std::make_unique<AACDecoder>();
    decoder->initialize();
    
    // åŸºäºéªŒè¯çš„ç‰ˆæœ¬ä¿¡æ¯æ£€æŸ¥
    auto lib_info = decoder->getLibraryInfo();
    
    // éªŒè¯æ ¸å¿ƒæ¨¡å—å­˜åœ¨ (åŸºäºéªŒè¯ç»“æœ)
    bool found_aac_decoder = false;
    for (const auto& module : lib_info) {
        if (module.title && std::string(module.title).find("AAC Decoder") != std::string::npos) {
            found_aac_decoder = true;
            
            // éªŒè¯ç‰ˆæœ¬æ ¼å¼ (åŸºäºéªŒè¯ç»“æœçš„æ ¼å¼)
            EXPECT_THAT(module.versionStr, ::testing::MatchesRegex("\\d+\\.\\d+\\.\\d+"));
            break;
        }
    }
    
    EXPECT_TRUE(found_aac_decoder);
}

TEST_F(AACDecoderTest, LicenseCompliance_CopyrightNotice) {
    // éªŒè¯æºç ä¸­åŒ…å«å¿…è¦çš„ç‰ˆæƒå£°æ˜
    std::ifstream source_file("../src/decoders/AACDecoder.cpp");
    std::string file_content((std::istreambuf_iterator<char>(source_file)),
                            std::istreambuf_iterator<char>());
    
    // åŸºäºéªŒè¯çš„ç‰ˆæƒè¦æ±‚
    EXPECT_THAT(file_content, ::testing::HasSubstr("FDK AAC Codec"));
    EXPECT_THAT(file_content, ::testing::HasSubstr("Fraunhofer"));
}
```
```

### 2.3 MiniMP4è§£å°è£…æµ‹è¯•ç”¨ä¾‹

#### 2.3.1 æ ‡å‡†MP4æ–‡ä»¶è§£ææµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: MP4_FUNC_001_StandardFilesParsing
åˆ†ç±»: åŠŸèƒ½æµ‹è¯• > æ–‡ä»¶è§£ææµ‹è¯•
ä¼˜å…ˆçº§: P0 (å…³é”®)
æè¿°: éªŒè¯MiniMP4æ­£ç¡®è§£æå„ç§æ ‡å‡†MP4æ–‡ä»¶

å‰ç½®æ¡ä»¶:
  - MiniMP4å·²æ­£ç¡®é›†æˆ (MINIMP4_IMPLEMENTATIONå®šä¹‰)
  - å‡†å¤‡æ ‡å‡†MP4æµ‹è¯•æ–‡ä»¶é›†åˆ

æµ‹è¯•æ­¥éª¤:
  1. è§£æåŒ…å«H.264+AACçš„æ ‡å‡†MP4æ–‡ä»¶
  2. éªŒè¯è½¨é“ä¿¡æ¯æå–æ­£ç¡®æ€§
  3. æµ‹è¯•SPS/PPSæå–åŠŸèƒ½
  4. éªŒè¯æ—¶é—´æˆ³å’ŒæŒç»­æ—¶é—´ä¿¡æ¯

æµ‹è¯•æ•°æ®:
  - standard_h264_aac.mp4 (æ ‡å‡†H.264+AACç»„åˆ)
  - multiple_tracks.mp4 (å¤šè½¨é“æ–‡ä»¶)
  - large_file_4gb_plus.mp4 (å¤§æ–‡ä»¶æµ‹è¯•)

é¢„æœŸç»“æœ:
  - MP4D_open()è¿”å›1 (æˆåŠŸ)
  - æ­£ç¡®è¯†åˆ«è§†é¢‘å’ŒéŸ³é¢‘è½¨é“
  - SPS/PPSæ•°æ®æå–å®Œæ•´
  - æ—¶é—´æˆ³ä¿¡æ¯å‡†ç¡®

åŸºäºéªŒè¯: MiniMP4 APIéªŒè¯å’ŒåŠŸèƒ½æµ‹è¯•ç»“æœ

å®ç°ç¤ºä¾‹:
```cpp
TEST_F(MP4DemuxerTest, StandardFilesParsing_BasicMP4) {
    auto demuxer = std::make_unique<MP4Demuxer>();
    
    std::string test_file = "test_data/standard_h264_aac.mp4";
    
    // åŸºäºéªŒè¯çš„æ–‡ä»¶æ‰“å¼€æµ‹è¯•
    ASSERT_TRUE(demuxer->open(test_file));
    
    // éªŒè¯è½¨é“ä¿¡æ¯ (åŸºäºéªŒè¯çš„è½¨é“æ£€æµ‹)
    auto tracks = demuxer->getTrackInfo();
    EXPECT_GE(tracks.size(), 2);  // è‡³å°‘è§†é¢‘+éŸ³é¢‘
    
    bool has_video = false, has_audio = false;
    for (const auto& track : tracks) {
        if (track.handler_type == MP4D_HANDLER_TYPE_VIDE) {
            has_video = true;
            EXPECT_EQ(track.object_type_indication, MP4_OBJECT_TYPE_AVC);
        } else if (track.handler_type == MP4D_HANDLER_TYPE_SOUN) {
            has_audio = true;
            EXPECT_EQ(track.object_type_indication, MP4_OBJECT_TYPE_AUDIO_ISO_IEC_14496_3);
        }
    }
    
    EXPECT_TRUE(has_video && has_audio);
}
```
```

#### 2.3.2 SPS/PPSæå–ç²¾ç¡®æ€§æµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: MP4_FUNC_002_SPSPPSExtraction
åˆ†ç±»: åŠŸèƒ½æµ‹è¯• > å‚æ•°é›†æå–æµ‹è¯•
ä¼˜å…ˆçº§: P0 (å…³é”®)
æè¿°: éªŒè¯ä»MP4æ–‡ä»¶æ­£ç¡®æå–H.264å‚æ•°é›†

å‰ç½®æ¡ä»¶:
  - MP4æ–‡ä»¶å·²æˆåŠŸæ‰“å¼€
  - åŒ…å«æœ‰æ•ˆçš„H.264è§†é¢‘è½¨é“

æµ‹è¯•æ­¥éª¤:
  1. æå–SPS (Sequence Parameter Set)
  2. æå–PPS (Picture Parameter Set)
  3. éªŒè¯å‚æ•°é›†æ•°æ®æ ¼å¼æ­£ç¡®æ€§
  4. æµ‹è¯•å¤šä¸ªSPS/PPSçš„å¤„ç†

æµ‹è¯•æ•°æ®:
  - h264_single_sps_pps.mp4
  - h264_multiple_sps_pps.mp4
  - h264_baseline_main_high.mp4

é¢„æœŸç»“æœ:
  - SPSæ•°æ®ä»¥NALå•å…ƒç±»å‹7å¼€å§‹
  - PPSæ•°æ®ä»¥NALå•å…ƒç±»å‹8å¼€å§‹
  - æ•°æ®é•¿åº¦åˆç† (é€šå¸¸SPS: 20-100å­—èŠ‚, PPS: 5-50å­—èŠ‚)
  - å¤šå‚æ•°é›†æ­£ç¡®åŒºåˆ†

åŸºäºéªŒè¯: MP4D_read_sps/MP4D_read_pps APIéªŒè¯

å®ç°ç¤ºä¾‹:
```cpp
TEST_F(MP4DemuxerTest, SPSPPSExtraction_Accuracy) {
    auto demuxer = std::make_unique<MP4Demuxer>();
    ASSERT_TRUE(demuxer->open("test_data/h264_single_sps_pps.mp4"));
    
    // æŸ¥æ‰¾H.264è§†é¢‘è½¨é“
    int video_track = -1;
    auto tracks = demuxer->getTrackInfo();
    for (int i = 0; i < tracks.size(); ++i) {
        if (tracks[i].object_type_indication == MP4_OBJECT_TYPE_AVC) {
            video_track = i;
            break;
        }
    }
    ASSERT_GE(video_track, 0);
    
    // åŸºäºéªŒè¯çš„SPS/PPSæå–æµ‹è¯•
    std::vector<uint8_t> sps_data, pps_data;
    ASSERT_TRUE(demuxer->extractSPS(video_track, 0, sps_data));
    ASSERT_TRUE(demuxer->extractPPS(video_track, 0, pps_data));
    
    // éªŒè¯NALå•å…ƒç±»å‹ (åŸºäºH.264æ ‡å‡†)
    ASSERT_GT(sps_data.size(), 0);
    ASSERT_GT(pps_data.size(), 0);
    
    EXPECT_EQ((sps_data[0] & 0x1F), 7);  // SPS NALç±»å‹
    EXPECT_EQ((pps_data[0] & 0x1F), 8);  // PPS NALç±»å‹
    
    // éªŒè¯æ•°æ®åˆç†æ€§
    EXPECT_LE(sps_data.size(), 200);  // SPSé€šå¸¸ä¸è¶…è¿‡200å­—èŠ‚
    EXPECT_LE(pps_data.size(), 100);  // PPSé€šå¸¸ä¸è¶…è¿‡100å­—èŠ‚
}
```
```

## 3. æ€§èƒ½æµ‹è¯•ç”¨ä¾‹è®¾è®¡

### 3.1 è§£ç æ€§èƒ½æµ‹è¯•ç”¨ä¾‹

#### 3.1.1 å®æ—¶è§£ç æ€§èƒ½æµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: H264_PERF_001_RealtimeDecoding
åˆ†ç±»: æ€§èƒ½æµ‹è¯• > è§£ç æ€§èƒ½æµ‹è¯•
ä¼˜å…ˆçº§: P1 (é‡è¦)
æè¿°: éªŒè¯H.264è§£ç å™¨æ»¡è¶³å®æ—¶æ’­æ”¾æ€§èƒ½è¦æ±‚

å‰ç½®æ¡ä»¶:
  - æµ‹è¯•ç¯å¢ƒCPUè´Ÿè½½ < 20%
  - å†…å­˜å¯ç”¨é‡ > 1GB
  - æµ‹è¯•æ–‡ä»¶å‡†å¤‡å®Œæˆ

æµ‹è¯•æ­¥éª¤:
  1. é¢„åŠ è½½æµ‹è¯•è§†é¢‘æ–‡ä»¶åˆ°å†…å­˜
  2. å¼€å§‹è®¡æ—¶ï¼Œè¿ç»­è§£ç æŒ‡å®šæ•°é‡å¸§
  3. è®°å½•è§£ç æ—¶é—´å’ŒCPUä½¿ç”¨ç‡
  4. è®¡ç®—å¹³å‡å¸§ç‡å’Œæ€§èƒ½æŒ‡æ ‡

æµ‹è¯•æ•°æ®:
  - h264_720p30_10sec.264 (720p, 30fps, 300å¸§)
  - h264_1080p30_10sec.264 (1080p, 30fps, 300å¸§)
  - h264_4k30_5sec.264 (4K, 30fps, 150å¸§)

æ€§èƒ½åŸºçº¿ (åŸºäºéªŒè¯ç»“æœ):
  - 720p@30fps: å¹³å‡è§£ç æ—¶é—´ < 30ms/å¸§
  - 1080p@30fps: å¹³å‡è§£ç æ—¶é—´ < 33ms/å¸§  
  - 4K@30fps: å¹³å‡è§£ç æ—¶é—´ < 50ms/å¸§ (å‚è€ƒç›®æ ‡)

é¢„æœŸç»“æœ:
  - æ‰€æœ‰æµ‹è¯•è¾¾åˆ°æˆ–è¶…è¿‡åŸºçº¿æ€§èƒ½
  - CPUä½¿ç”¨ç‡ç¨³å®šï¼Œæ— æ˜¾è‘—æ³¢åŠ¨
  - å†…å­˜ä½¿ç”¨é‡ç¨³å®šåœ¨éªŒè¯èŒƒå›´å†…

å®ç°ç¤ºä¾‹:
```cpp
TEST_F(H264PerformanceTest, RealtimeDecoding_1080p30) {
    auto decoder = std::make_unique<H264Decoder>();
    ASSERT_TRUE(decoder->initialize());
    
    auto test_data = loadTestSequence("h264_1080p30_10sec.264");
    const int target_fps = 30;
    const int total_frames = 300;
    
    auto start_time = std::chrono::high_resolution_clock::now();
    
    for (int frame = 0; frame < total_frames; ++frame) {
        uint8_t* output_yuv = nullptr;
        bool success = decoder->decodeFrame(
            test_data.frames[frame].data, 
            test_data.frames[frame].size, 
            &output_yuv
        );
        
        ASSERT_TRUE(success) << "Frame " << frame << " decode failed";
        ASSERT_NE(output_yuv, nullptr);
    }
    
    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
        end_time - start_time);
    
    // åŸºäºéªŒè¯ç»“æœçš„æ€§èƒ½éªŒè¯
    double avg_frame_time = static_cast<double>(duration.count()) / total_frames;
    double achieved_fps = 1000.0 / avg_frame_time;
    
    EXPECT_LT(avg_frame_time, 33.33);  // < 33.33ms per frame for 30fps
    EXPECT_GE(achieved_fps, target_fps);
    
    // è®°å½•æ€§èƒ½æ•°æ®ç”¨äºè¶‹åŠ¿åˆ†æ
    recordPerformanceMetric("h264_1080p30_decode_time", avg_frame_time);
    recordPerformanceMetric("h264_1080p30_achieved_fps", achieved_fps);
}
```
```

#### 3.1.2 å†…å­˜ä½¿ç”¨æ•ˆç‡æµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: ALL_PERF_002_MemoryEfficiency
åˆ†ç±»: æ€§èƒ½æµ‹è¯• > å†…å­˜ä½¿ç”¨æµ‹è¯•
ä¼˜å…ˆçº§: P1 (é‡è¦)
æè¿°: éªŒè¯è§£ç å™¨å†…å­˜ä½¿ç”¨æ•ˆç‡å’Œç¨³å®šæ€§

å‰ç½®æ¡ä»¶:
  - ç³»ç»Ÿå†…å­˜ç›‘æ§å·¥å…·å·²å‡†å¤‡
  - é•¿æ—¶é—´æµ‹è¯•è§†é¢‘æ–‡ä»¶å·²å‡†å¤‡
  - åŸºçº¿å†…å­˜ä½¿ç”¨é‡å·²è®°å½•

æµ‹è¯•æ­¥éª¤:
  1. è®°å½•è¿›ç¨‹å¯åŠ¨æ—¶å†…å­˜åŸºçº¿
  2. åˆå§‹åŒ–æ‰€æœ‰è§£ç å™¨ (H264, AAC, MP4)
  3. è¿ç»­è§£ç é•¿è§†é¢‘æ–‡ä»¶ (2å°æ—¶)
  4. æ¯10åˆ†é’Ÿè®°å½•å†…å­˜ä½¿ç”¨é‡
  5. éªŒè¯å†…å­˜å¢é•¿è¶‹åŠ¿

æµ‹è¯•æ•°æ®:
  - long_movie_h264_aac_2hours.mp4
  - memory_stress_4k_1hour.mp4

å†…å­˜åŸºçº¿ (åŸºäºéªŒè¯ç»“æœ):
  - è¿›ç¨‹åŸºçº¿å†…å­˜: < 50MB
  - H264è§£ç å™¨: < 100KBä¸Šä¸‹æ–‡
  - AACè§£ç å™¨: < 200KBä¸Šä¸‹æ–‡
  - ç¼“å†²åŒºæ€»é‡: < 10MB
  - æ€»å†…å­˜ä¸Šé™: < 200MB

é¢„æœŸç»“æœ:
  - å†…å­˜ä½¿ç”¨é‡ç¨³å®šåœ¨åŸºçº¿èŒƒå›´å†…
  - æ— æ˜æ˜¾å†…å­˜æ³„æ¼ (å¢é•¿ < 1MB/å°æ—¶)
  - å³°å€¼å†…å­˜ä¸è¶…è¿‡ä¸Šé™çš„120%

å®ç°ç¤ºä¾‹:
```cpp
TEST_F(MemoryEfficiencyTest, LongTermMemoryStability) {
    // è®°å½•åŸºçº¿å†…å­˜
    size_t baseline_memory = getCurrentProcessMemoryUsage();
    
    // åˆå§‹åŒ–å®Œæ•´è§£ç ç®¡é“
    auto movie = std::make_unique<H264Movie>();
    ASSERT_TRUE(movie->loadFromFile("test_data/long_movie_h264_aac_2hours.mp4"));
    
    size_t post_init_memory = getCurrentProcessMemoryUsage();
    size_t init_overhead = post_init_memory - baseline_memory;
    
    // åŸºäºéªŒè¯ç»“æœçš„å†…å­˜ä½¿ç”¨éªŒè¯
    EXPECT_LT(init_overhead, 200 * 1024 * 1024);  // < 200MBåˆå§‹åŒ–å¼€é”€
    
    // å¼€å§‹é•¿æ—¶é—´æ’­æ”¾æµ‹è¯•
    ASSERT_TRUE(movie->play());
    
    auto start_time = std::chrono::steady_clock::now();
    auto last_check_time = start_time;
    size_t max_memory = post_init_memory;
    
    // æ’­æ”¾2å°æ—¶ï¼Œæ¯10åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡å†…å­˜
    while (true) {
        auto current_time = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::hours>(
            current_time - start_time);
        
        if (elapsed.count() >= 2) break;  // 2å°æ—¶æµ‹è¯•å®Œæˆ
        
        auto check_elapsed = std::chrono::duration_cast<std::chrono::minutes>(
            current_time - last_check_time);
        
        if (check_elapsed.count() >= 10) {  // æ¯10åˆ†é’Ÿæ£€æŸ¥
            size_t current_memory = getCurrentProcessMemoryUsage();
            max_memory = std::max(max_memory, current_memory);
            
            // æ£€æŸ¥å†…å­˜æ³„æ¼
            size_t memory_growth = current_memory - post_init_memory;
            double hours_elapsed = static_cast<double>(
                std::chrono::duration_cast<std::chrono::minutes>(
                    current_time - start_time).count()) / 60.0;
            double growth_per_hour = memory_growth / hours_elapsed;
            
            EXPECT_LT(growth_per_hour, 1024 * 1024);  // < 1MB/hourå¢é•¿
            
            last_check_time = current_time;
        }
        
        std::this_thread::sleep_for(std::chrono::seconds(30));
    }
    
    movie->stop();
    
    // æœ€ç»ˆå†…å­˜æ£€æŸ¥
    size_t final_memory = getCurrentProcessMemoryUsage();
    EXPECT_LT(max_memory - post_init_memory, 50 * 1024 * 1024);  // < 50MBå¢é•¿
}
```
```

### 3.2 å¹¶å‘æ€§èƒ½æµ‹è¯•ç”¨ä¾‹

#### 3.2.1 å¤šå®ä¾‹å¹¶å‘æµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: ALL_PERF_003_ConcurrentInstances
åˆ†ç±»: æ€§èƒ½æµ‹è¯• > å¹¶å‘æ€§èƒ½æµ‹è¯•
ä¼˜å…ˆçº§: P2 (ä¸€èˆ¬)
æè¿°: éªŒè¯å¤šä¸ªè§£ç å®ä¾‹å¹¶å‘è¿è¡Œçš„æ€§èƒ½å’Œç¨³å®šæ€§

å‰ç½®æ¡ä»¶:
  - å¤šæ ¸CPUç¯å¢ƒ (è‡³å°‘4æ ¸)
  - å……è¶³çš„ç³»ç»Ÿå†…å­˜ (è‡³å°‘4GB)
  - å¤šä¸ªæµ‹è¯•è§†é¢‘æ–‡ä»¶

æµ‹è¯•æ­¥éª¤:
  1. åŒæ—¶åˆ›å»ºå¤šä¸ªH264Movieå®ä¾‹ (2-8ä¸ª)
  2. å¹¶å‘æ’­æ”¾ä¸åŒçš„è§†é¢‘æ–‡ä»¶
  3. ç›‘æ§ç³»ç»Ÿèµ„æºä½¿ç”¨æƒ…å†µ
  4. éªŒè¯è§£ç è´¨é‡æ— é™çº§

æµ‹è¯•æ•°æ®:
  - movie_1_720p30.mp4
  - movie_2_1080p24.mp4  
  - movie_3_480p30.mp4
  - movie_4_720p25.mp4

æ€§èƒ½é¢„æœŸ:
  - 2ä¸ªå®ä¾‹: æ€»CPU < 50%
  - 4ä¸ªå®ä¾‹: æ€»CPU < 80%
  - 8ä¸ªå®ä¾‹: å¯èƒ½é™çº§ä½†ä¸å´©æºƒ
  - å†…å­˜ä½¿ç”¨é‡çº¿æ€§å¢é•¿

å®ç°ç¤ºä¾‹:
```cpp
TEST_F(ConcurrentPerformanceTest, MultipleInstances_FourMovies) {
    const int num_instances = 4;
    std::vector<std::unique_ptr<H264Movie>> movies;
    std::vector<std::thread> playback_threads;
    
    std::vector<std::string> test_files = {
        "test_data/movie_1_720p30.mp4",
        "test_data/movie_2_1080p24.mp4", 
        "test_data/movie_3_480p30.mp4",
        "test_data/movie_4_720p25.mp4"
    };
    
    // åˆ›å»ºå¤šä¸ªç”µå½±å®ä¾‹
    for (int i = 0; i < num_instances; ++i) {
        auto movie = std::make_unique<H264Movie>();
        ASSERT_TRUE(movie->loadFromFile(test_files[i]));
        movies.push_back(std::move(movie));
    }
    
    size_t baseline_memory = getCurrentProcessMemoryUsage();
    auto start_time = std::chrono::steady_clock::now();
    
    // å¯åŠ¨å¹¶å‘æ’­æ”¾çº¿ç¨‹
    std::atomic<int> successful_playbacks{0};
    for (int i = 0; i < num_instances; ++i) {
        playback_threads.emplace_back([&, i]() {
            if (movies[i]->play()) {
                // æ’­æ”¾30ç§’
                std::this_thread::sleep_for(std::chrono::seconds(30));
                movies[i]->stop();
                successful_playbacks++;
            }
        });
    }
    
    // ç›‘æ§ç³»ç»Ÿèµ„æºä½¿ç”¨
    double max_cpu_usage = 0.0;
    size_t max_memory_usage = baseline_memory;
    
    while (successful_playbacks < num_instances) {
        double current_cpu = getCurrentProcessCPUUsage();
        size_t current_memory = getCurrentProcessMemoryUsage();
        
        max_cpu_usage = std::max(max_cpu_usage, current_cpu);
        max_memory_usage = std::max(max_memory_usage, current_memory);
        
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for (auto& thread : playback_threads) {
        thread.join();
    }
    
    // éªŒè¯æ€§èƒ½æŒ‡æ ‡
    EXPECT_EQ(successful_playbacks, num_instances);
    EXPECT_LT(max_cpu_usage, 80.0);  // < 80% CPU usage
    
    size_t memory_overhead = max_memory_usage - baseline_memory;
    size_t expected_overhead = num_instances * 200 * 1024 * 1024;  // 200MB per instance
    EXPECT_LT(memory_overhead, expected_overhead);
}
```
```

## 4. å…¼å®¹æ€§æµ‹è¯•ç”¨ä¾‹è®¾è®¡

### 4.1 å¹³å°å…¼å®¹æ€§æµ‹è¯•ç”¨ä¾‹

#### 4.1.1 iOSå¹³å°ç‰¹å®šæµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: IOS_COMPAT_001_MetalIntegration  
åˆ†ç±»: å…¼å®¹æ€§æµ‹è¯• > å¹³å°å…¼å®¹æ€§æµ‹è¯•
ä¼˜å…ˆçº§: P1 (é‡è¦)
æè¿°: éªŒè¯iOSå¹³å°Metalçº¹ç†æ¸²æŸ“é›†æˆ

å‰ç½®æ¡ä»¶:
  - iOSè®¾å¤‡æˆ–æ¨¡æ‹Ÿå™¨ (iOS 15.0+)
  - Metalæ¸²æŸ“ç®¡é“å·²åˆå§‹åŒ–
  - æµ‹è¯•è§†é¢‘æ–‡ä»¶å¯è®¿é—®

æµ‹è¯•æ­¥éª¤:
  1. åˆå§‹åŒ–Metalè®¾å¤‡å’Œå‘½ä»¤é˜Ÿåˆ—
  2. åˆ›å»ºMetalçº¹ç†å¯¹è±¡
  3. è§£ç è§†é¢‘å¸§å¹¶ä¸Šä¼ åˆ°Metalçº¹ç†
  4. éªŒè¯çº¹ç†æ•°æ®æ­£ç¡®æ€§

æµ‹è¯•æ•°æ®:
  - ios_test_h264_720p.mp4
  - ios_test_h264_1080p.mp4

é¢„æœŸç»“æœ:
  - Metalè®¾å¤‡åˆå§‹åŒ–æˆåŠŸ
  - çº¹ç†åˆ›å»ºå’Œæ›´æ–°æ— é”™è¯¯
  - æ¸²æŸ“æ€§èƒ½æ»¡è¶³60fpsè¦æ±‚
  - å†…å­˜ä½¿ç”¨åˆç†

ä»…åœ¨iOSå¹³å°æ‰§è¡Œ:
```objc
#if TARGET_OS_IOS
TEST_F(IOSCompatibilityTest, MetalIntegration) {
    // åˆå§‹åŒ–Metalè®¾å¤‡
    id<MTLDevice> device = MTLCreateSystemDefaultDevice();
    ASSERT_TRUE(device != nil);
    
    auto movie = std::make_unique<H264Movie>();
    ASSERT_TRUE(movie->loadFromFile("test_data/ios_test_h264_720p.mp4"));
    
    // åˆ›å»ºMetalçº¹ç†æ¸²æŸ“å™¨
    auto metal_renderer = std::make_unique<MetalTextureRenderer>(device);
    ASSERT_TRUE(metal_renderer->initialize());
    
    ASSERT_TRUE(movie->play());
    
    // éªŒè¯Metalçº¹ç†æ›´æ–°
    for (int frame = 0; frame < 30; ++frame) {
        if (movie->hasNewVideoFrame()) {
            auto yuv_frame = movie->getCurrentVideoFrame();
            
            id<MTLTexture> metal_texture = metal_renderer->updateTexture(yuv_frame);
            ASSERT_TRUE(metal_texture != nil);
            EXPECT_EQ([metal_texture width], yuv_frame.width);
            EXPECT_EQ([metal_texture height], yuv_frame.height);
        }
        
        std::this_thread::sleep_for(std::chrono::milliseconds(33));  // ~30fps
    }
    
    movie->stop();
}
#endif
```
```

#### 4.1.2 Androidå¹³å°ç‰¹å®šæµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: ANDROID_COMPAT_001_OpenGLESIntegration
åˆ†ç±»: å…¼å®¹æ€§æµ‹è¯• > å¹³å°å…¼å®¹æ€§æµ‹è¯•  
ä¼˜å…ˆçº§: P1 (é‡è¦)
æè¿°: éªŒè¯Androidå¹³å°OpenGL ESçº¹ç†æ¸²æŸ“é›†æˆ

å‰ç½®æ¡ä»¶:
  - Androidè®¾å¤‡æˆ–æ¨¡æ‹Ÿå™¨ (API 26+)
  - OpenGL ES 3.0+ æ”¯æŒ
  - EGLä¸Šä¸‹æ–‡å·²åˆ›å»º

æµ‹è¯•æ­¥éª¤:
  1. åˆ›å»ºOpenGL ESä¸Šä¸‹æ–‡
  2. ç”Ÿæˆçº¹ç†å¯¹è±¡å’Œç€è‰²å™¨ç¨‹åº
  3. ä¸Šä¼ YUVæ•°æ®åˆ°OpenGLçº¹ç†
  4. æ‰§è¡ŒYUVåˆ°RGBè½¬æ¢æ¸²æŸ“

æµ‹è¯•æ•°æ®:
  - android_test_h264_720p.mp4
  - android_test_various_formats.mp4

é¢„æœŸç»“æœ:
  - OpenGL ESä¸Šä¸‹æ–‡åˆ›å»ºæˆåŠŸ
  - çº¹ç†ä¸Šä¼ å’Œè½¬æ¢æ­£ç¡®
  - æ¸²æŸ“æ€§èƒ½æ»¡è¶³å®æ—¶è¦æ±‚
  - æ— OpenGLé”™è¯¯

ä»…åœ¨Androidå¹³å°æ‰§è¡Œ:
```cpp
#ifdef __ANDROID__
TEST_F(AndroidCompatibilityTest, OpenGLESIntegration) {
    // åˆå§‹åŒ–EGLå’ŒOpenGL ESä¸Šä¸‹æ–‡
    auto egl_context = std::make_unique<EGLContext>();
    ASSERT_TRUE(egl_context->initialize());
    
    auto movie = std::make_unique<H264Movie>();
    ASSERT_TRUE(movie->loadFromFile("/data/local/tmp/android_test_h264_720p.mp4"));
    
    // åˆ›å»ºOpenGL ESçº¹ç†æ¸²æŸ“å™¨
    auto gles_renderer = std::make_unique<GLESTextureRenderer>();
    ASSERT_TRUE(gles_renderer->initialize());
    
    ASSERT_TRUE(movie->play());
    
    // éªŒè¯OpenGL ESçº¹ç†æ¸²æŸ“
    for (int frame = 0; frame < 30; ++frame) {
        if (movie->hasNewVideoFrame()) {
            auto yuv_frame = movie->getCurrentVideoFrame();
            
            GLuint texture_id = gles_renderer->uploadYUVTexture(yuv_frame);
            EXPECT_NE(texture_id, 0);
            
            // éªŒè¯çº¹ç†å‚æ•°
            GLint width, height;
            glBindTexture(GL_TEXTURE_2D, texture_id);
            glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &width);
            glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, &height);
            
            EXPECT_EQ(width, yuv_frame.width);
            EXPECT_EQ(height, yuv_frame.height);
            EXPECT_EQ(glGetError(), GL_NO_ERROR);
        }
        
        std::this_thread::sleep_for(std::chrono::milliseconds(33));
    }
    
    movie->stop();
}
#endif
```
```

### 4.2 æ–‡ä»¶æ ¼å¼å…¼å®¹æ€§æµ‹è¯•ç”¨ä¾‹

#### 4.2.1 å¤šç¼–ç å™¨å…¼å®¹æ€§æµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: FORMAT_COMPAT_001_MultipleEncoders
åˆ†ç±»: å…¼å®¹æ€§æµ‹è¯• > æ–‡ä»¶æ ¼å¼å…¼å®¹æ€§æµ‹è¯•
ä¼˜å…ˆçº§: P1 (é‡è¦)
æè¿°: éªŒè¯å¯¹ä¸åŒç¼–ç å™¨ç”Ÿæˆçš„H.264æ–‡ä»¶å…¼å®¹æ€§

å‰ç½®æ¡ä»¶:
  - å¤šç§ç¼–ç å™¨ç”Ÿæˆçš„æµ‹è¯•æ–‡ä»¶å·²å‡†å¤‡
  - å‚è€ƒè§£ç è¾“å‡ºå·²éªŒè¯

æµ‹è¯•æ­¥éª¤:
  1. é€ä¸€æµ‹è¯•ä¸åŒç¼–ç å™¨ç”Ÿæˆçš„æ–‡ä»¶
  2. æ¯”è¾ƒè§£ç è¾“å‡ºè´¨é‡
  3. éªŒè¯è§£ç æ€§èƒ½ä¸€è‡´æ€§
  4. æ£€æŸ¥ç‰¹æ®Šå‚æ•°å¤„ç†

æµ‹è¯•æ•°æ®:
  - x264_encoder_output.mp4 (å¼€æºx264ç¼–ç å™¨)
  - ffmpeg_encoder_output.mp4 (FFmpeg libx264)
  - hardware_encoder_output.mp4 (ç¡¬ä»¶ç¼–ç å™¨)
  - mobile_encoder_output.mp4 (ç§»åŠ¨è®¾å¤‡ç¼–ç )

ç¼–ç å™¨å…¼å®¹æ€§çŸ©é˜µ:
  - x264 (å¼€æº): âœ“ å®Œå…¨å…¼å®¹
  - FFmpeg: âœ“ å®Œå…¨å…¼å®¹
  - Intel QSV: âœ“ åŸºç¡€å…¼å®¹
  - NVIDIA NVENC: âœ“ åŸºç¡€å…¼å®¹
  - iOSç¡¬ä»¶ç¼–ç : âœ“ éœ€æµ‹è¯•
  - Android MediaCodec: âœ“ éœ€æµ‹è¯•

å®ç°ç¤ºä¾‹:
```cpp
class MultiEncoderCompatibilityTest : public ::testing::TestWithParam<std::string> {};

INSTANTIATE_TEST_SUITE_P(
    EncoderCompatibility,
    MultiEncoderCompatibilityTest,
    ::testing::Values(
        "x264_encoder_output.mp4",
        "ffmpeg_encoder_output.mp4", 
        "hardware_encoder_output.mp4",
        "mobile_encoder_output.mp4"
    )
);

TEST_P(MultiEncoderCompatibilityTest, DecodingCompatibility) {
    std::string test_file = GetParam();
    std::string full_path = "test_data/encoder_compatibility/" + test_file;
    
    auto movie = std::make_unique<H264Movie>();
    
    // åŸºæœ¬å…¼å®¹æ€§æµ‹è¯•
    bool load_success = movie->loadFromFile(full_path);
    EXPECT_TRUE(load_success) << "Failed to load file from: " << test_file;
    
    if (load_success) {
        EXPECT_TRUE(movie->play());
        
        // è§£ç å‡ å¸§éªŒè¯è´¨é‡
        int decoded_frames = 0;
        auto start_time = std::chrono::steady_clock::now();
        
        while (decoded_frames < 30) {  // è§£ç 30å¸§
            if (movie->hasNewVideoFrame()) {
                auto frame = movie->getCurrentVideoFrame();
                EXPECT_GT(frame.width, 0);
                EXPECT_GT(frame.height, 0);
                EXPECT_TRUE(frame.isValid());
                
                decoded_frames++;
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
        
        auto end_time = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
            end_time - start_time);
        
        // æ€§èƒ½ä¸€è‡´æ€§æ£€æŸ¥
        double avg_decode_time = static_cast<double>(duration.count()) / decoded_frames;
        EXPECT_LT(avg_decode_time, 50.0)  // æ¯å¸§è§£ç æ—¶é—´<50ms
            << "Slow decoding for encoder: " << test_file;
        
        movie->stop();
    }
}
```
```

## 5. å¯é æ€§æµ‹è¯•ç”¨ä¾‹è®¾è®¡

### 5.1 å¼‚å¸¸å¤„ç†æµ‹è¯•ç”¨ä¾‹

#### 5.1.1 æ–‡ä»¶æŸåå¤„ç†æµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: RELIABILITY_001_CorruptedFileHandling
åˆ†ç±»: å¯é æ€§æµ‹è¯• > å¼‚å¸¸å¤„ç†æµ‹è¯•
ä¼˜å…ˆçº§: P1 (é‡è¦)
æè¿°: éªŒè¯å¯¹æŸåæˆ–ä¸å®Œæ•´æ–‡ä»¶çš„å¤„ç†èƒ½åŠ›

å‰ç½®æ¡ä»¶:
  - å‡†å¤‡å„ç§æŸåæ¨¡å¼çš„æµ‹è¯•æ–‡ä»¶
  - æ­£å¸¸æ–‡ä»¶ä½œä¸ºå¯¹ç…§ç»„

æµ‹è¯•æ­¥éª¤:
  1. æµ‹è¯•æˆªæ–­æ–‡ä»¶å¤„ç†
  2. æµ‹è¯•éšæœºæŸåæ•°æ®å¤„ç†
  3. æµ‹è¯•å¤´éƒ¨æŸåæ–‡ä»¶å¤„ç†
  4. éªŒè¯é”™è¯¯æŠ¥å‘Šå‡†ç¡®æ€§

æŸåæ–‡ä»¶ç±»å‹:
  - truncated_file.mp4 (æ–‡ä»¶æˆªæ–­)
  - random_corruption.mp4 (éšæœºå­—èŠ‚æŸå)
  - header_corrupted.mp4 (æ–‡ä»¶å¤´æŸå)
  - missing_sps_pps.mp4 (ç¼ºå°‘å‚æ•°é›†)

é¢„æœŸè¡Œä¸º:
  - ä¼˜é›…å¤„ç†ï¼Œä¸å´©æºƒ
  - è¿”å›å‡†ç¡®çš„é”™è¯¯ä¿¡æ¯
  - èµ„æºæ­£ç¡®æ¸…ç†
  - é”™è¯¯ç ç¬¦åˆæ–‡æ¡£è§„èŒƒ

å®ç°ç¤ºä¾‹:
```cpp
class CorruptedFileTest : public ::testing::TestWithParam<
    std::tuple<std::string, std::string, H264Error>> {};

INSTANTIATE_TEST_SUITE_P(
    CorruptedFiles,
    CorruptedFileTest,
    ::testing::Values(
        std::make_tuple("truncated_file.mp4", "File truncated", H264Error::MP4_READ_FAILED),
        std::make_tuple("random_corruption.mp4", "Data corruption", H264Error::MP4_INVALID_FORMAT),
        std::make_tuple("header_corrupted.mp4", "Invalid header", H264Error::MP4_OPEN_FAILED),
        std::make_tuple("missing_sps_pps.mp4", "Missing SPS/PPS", H264Error::H264_DECODE_FAILED)
    )
);

TEST_P(CorruptedFileTest, GracefulErrorHandling) {
    auto [filename, description, expected_error] = GetParam();
    
    std::string full_path = "test_data/corrupted/" + filename;
    
    auto movie = std::make_unique<H264Movie>();
    
    // æœŸæœ›åŠ è½½å¤±è´¥ä½†ä¸å´©æºƒ
    bool load_result = movie->loadFromFile(full_path);
    EXPECT_FALSE(load_result) << "Corrupted file should not load successfully: " << filename;
    
    // éªŒè¯é”™è¯¯ä¿¡æ¯
    EXPECT_TRUE(movie->hasError());
    
    H264Error error_code = movie->getLastErrorCode();
    EXPECT_EQ(error_code, expected_error) << "Wrong error code for: " << filename;
    
    std::string error_message = movie->getLastError();
    EXPECT_FALSE(error_message.empty()) << "Error message should not be empty";
    EXPECT_THAT(error_message, ::testing::HasSubstr(description));
    
    // éªŒè¯èµ„æºæ¸…ç†
    size_t memory_before = getCurrentProcessMemoryUsage();
    movie.reset();  // é”€æ¯å¯¹è±¡
    size_t memory_after = getCurrentProcessMemoryUsage();
    
    // å†…å­˜åº”è¯¥è¢«æ­£ç¡®é‡Šæ”¾ (å…è®¸ä¸€äº›ç³»ç»Ÿå¼€é”€)
    EXPECT_LT(memory_after - memory_before, 1024 * 1024);  // < 1MBå·®å¼‚
}
```
```

### 5.2 å‹åŠ›æµ‹è¯•ç”¨ä¾‹

#### 5.2.1 æé™æ¡ä»¶å‹åŠ›æµ‹è¯•
```yaml
æµ‹è¯•ç”¨ä¾‹: STRESS_001_ExtremeConditions
åˆ†ç±»: å¯é æ€§æµ‹è¯• > å‹åŠ›æµ‹è¯•
ä¼˜å…ˆçº§: P2 (ä¸€èˆ¬)
æè¿°: åœ¨æé™æ¡ä»¶ä¸‹æµ‹è¯•ç³»ç»Ÿç¨³å®šæ€§

æµ‹è¯•åœºæ™¯:
  - ä½å†…å­˜ç¯å¢ƒ (å¯ç”¨å†…å­˜<100MB)
  - é«˜CPUè´Ÿè½½ç¯å¢ƒ (CPUä½¿ç”¨ç‡>90%)
  - ç£ç›˜I/Oç¹å¿™ç¯å¢ƒ
  - ç½‘ç»œä¸ç¨³å®šç¯å¢ƒ (å¦‚æœæ¶‰åŠæµåª’ä½“)

æµ‹è¯•æ­¥éª¤:
  1. åˆ›å»ºæé™ç¯å¢ƒæ¡ä»¶
  2. åœ¨è¯¥ç¯å¢ƒä¸‹è¿è¡Œæ­£å¸¸æ’­æ”¾æµ‹è¯•
  3. ç›‘æ§ç³»ç»Ÿè¡Œä¸ºå’Œé”™è¯¯å¤„ç†
  4. éªŒè¯æ¢å¤èƒ½åŠ›

é¢„æœŸç»“æœ:
  - ç³»ç»Ÿä¸å´©æºƒ
  - æ€§èƒ½é™çº§ä½†åŠŸèƒ½å¯ç”¨
  - é”™è¯¯å¤„ç†æ­£ç¡®
  - èµ„æºä½¿ç”¨åˆç†

å®ç°ç¤ºä¾‹:
```cpp
TEST_F(StressTest, LowMemoryEnvironment) {
    // åˆ›å»ºå†…å­˜å‹åŠ› (æ¶ˆè€—å¤§éƒ¨åˆ†å¯ç”¨å†…å­˜)
    std::vector<std::unique_ptr<uint8_t[]>> memory_hogs;
    size_t total_allocated = 0;
    const size_t chunk_size = 10 * 1024 * 1024;  // 10MB chunks
    
    // åˆ†é…å†…å­˜ç›´åˆ°åªå‰©100MBå¯ç”¨
    while (getAvailableMemory() > 100 * 1024 * 1024) {
        try {
            auto chunk = std::make_unique<uint8_t[]>(chunk_size);
            memset(chunk.get(), 0, chunk_size);  // ç¡®ä¿ç‰©ç†åˆ†é…
            memory_hogs.push_back(std::move(chunk));
            total_allocated += chunk_size;
        } catch (const std::bad_alloc&) {
            break;  // æ— æ³•ç»§ç»­åˆ†é…
        }
    }
    
    GTEST_LOG_(INFO) << "Allocated " << total_allocated / (1024*1024) 
                     << "MB to create memory pressure";
    
    // åœ¨ä½å†…å­˜ç¯å¢ƒä¸‹æµ‹è¯•æ’­æ”¾åŠŸèƒ½
    auto movie = std::make_unique<H264Movie>();
    
    bool load_success = movie->loadFromFile("test_data/standard_h264_aac.mp4");
    
    if (load_success) {
        EXPECT_TRUE(movie->play());
        
        // æ’­æ”¾ä¸€æ®µæ—¶é—´ï¼Œç›‘æ§ç¨³å®šæ€§
        auto start_time = std::chrono::steady_clock::now();
        while (std::chrono::duration_cast<std::chrono::seconds>(
            std::chrono::steady_clock::now() - start_time).count() < 30) {
            
            // æ£€æŸ¥æ’­æ”¾çŠ¶æ€
            EXPECT_FALSE(movie->hasError()) << "Error during low memory playback: " 
                                           << movie->getLastError();
            
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
        
        movie->stop();
    } else {
        // ä½å†…å­˜æƒ…å†µä¸‹åŠ è½½å¤±è´¥æ˜¯å¯æ¥å—çš„
        GTEST_LOG_(INFO) << "File load failed in low memory environment (acceptable): " 
                         << movie->getLastError();
    }
    
    // æ¸…ç†å†…å­˜å‹åŠ›
    memory_hogs.clear();
}
```
```

## 6. æµ‹è¯•æ•°æ®ç®¡ç†

### 6.1 æµ‹è¯•æ•°æ®è§„èŒƒ
```yaml
æµ‹è¯•æ•°æ®ç›®å½•ç»“æ„:
test_data/
â”œâ”€â”€ standard/                    # æ ‡å‡†æµ‹è¯•æ–‡ä»¶
â”‚   â”œâ”€â”€ h264_baseline_720p30.mp4
â”‚   â”œâ”€â”€ h264_main_1080p30.mp4  
â”‚   â”œâ”€â”€ aac_stereo_48khz.mp4
â”‚   â””â”€â”€ checksums.md5
â”œâ”€â”€ performance/                 # æ€§èƒ½æµ‹è¯•æ–‡ä»¶
â”‚   â”œâ”€â”€ benchmark_720p30_10sec.mp4
â”‚   â”œâ”€â”€ benchmark_1080p30_10sec.mp4
â”‚   â””â”€â”€ long_duration_2hours.mp4
â”œâ”€â”€ compatibility/               # å…¼å®¹æ€§æµ‹è¯•æ–‡ä»¶
â”‚   â”œâ”€â”€ encoder_specific/
â”‚   â”œâ”€â”€ platform_specific/
â”‚   â””â”€â”€ format_variations/
â”œâ”€â”€ corrupted/                   # æŸåæ–‡ä»¶æµ‹è¯•
â”‚   â”œâ”€â”€ truncated_file.mp4
â”‚   â”œâ”€â”€ random_corruption.mp4
â”‚   â””â”€â”€ header_corrupted.mp4
â”œâ”€â”€ reference/                   # å‚è€ƒæ•°æ®
â”‚   â”œâ”€â”€ yuv420_frames/
â”‚   â”œâ”€â”€ pcm_audio_samples/
â”‚   â””â”€â”€ quality_metrics.json
â””â”€â”€ tools/                       # æµ‹è¯•å·¥å…·
    â”œâ”€â”€ generate_test_data.py
    â”œâ”€â”€ verify_checksums.py
    â””â”€â”€ create_corrupted_files.py
```

### 6.2 æµ‹è¯•æ•°æ®ç”Ÿæˆå·¥å…·
```python
#!/usr/bin/env python3
# tools/generate_test_data.py

import subprocess
import hashlib
import json
from pathlib import Path

class TestDataGenerator:
    def __init__(self, output_dir):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
    def generate_h264_test_files(self):
        """ç”Ÿæˆæ ‡å‡†H.264æµ‹è¯•æ–‡ä»¶"""
        configs = [
            {
                'name': 'h264_baseline_720p30',
                'resolution': '1280x720',
                'fps': 30,
                'profile': 'baseline',
                'duration': 10
            },
            {
                'name': 'h264_main_1080p30', 
                'resolution': '1920x1080',
                'fps': 30,
                'profile': 'main',
                'duration': 10
            }
        ]
        
        for config in configs:
            output_file = self.output_dir / f"{config['name']}.mp4"
            
            # ä½¿ç”¨FFmpegç”Ÿæˆæµ‹è¯•è§†é¢‘
            cmd = [
                'ffmpeg', '-y',
                '-f', 'lavfi',
                '-i', f"testsrc2=size={config['resolution']}:rate={config['fps']}:duration={config['duration']}",
                '-c:v', 'libx264',
                '-profile:v', config['profile'],
                '-preset', 'medium',
                '-crf', '23',
                str(output_file)
            ]
            
            try:
                subprocess.run(cmd, check=True, capture_output=True)
                print(f"Generated: {output_file}")
                
                # è®¡ç®—æ–‡ä»¶æ ¡éªŒå’Œ
                checksum = self.calculate_md5(output_file)
                self.save_checksum(output_file.name, checksum)
                
            except subprocess.CalledProcessError as e:
                print(f"Failed to generate {output_file}: {e}")
    
    def generate_corrupted_files(self):
        """ç”ŸæˆæŸåæ–‡ä»¶ç”¨äºæµ‹è¯•"""
        source_file = self.output_dir / "h264_baseline_720p30.mp4"
        if not source_file.exists():
            print("Source file not found, generating standard files first")
            self.generate_h264_test_files()
        
        # ç”Ÿæˆæˆªæ–­æ–‡ä»¶
        truncated_file = self.output_dir.parent / "corrupted" / "truncated_file.mp4"
        truncated_file.parent.mkdir(parents=True, exist_ok=True)
        
        with open(source_file, 'rb') as src, open(truncated_file, 'wb') as dst:
            data = src.read()
            # æˆªæ–­åˆ°50%
            dst.write(data[:len(data)//2])
        
        # ç”ŸæˆéšæœºæŸåæ–‡ä»¶  
        corrupted_file = truncated_file.parent / "random_corruption.mp4"
        with open(source_file, 'rb') as src, open(corrupted_file, 'wb') as dst:
            data = bytearray(src.read())
            # éšæœºæŸå1%çš„å­—èŠ‚
            import random
            for _ in range(len(data) // 100):
                pos = random.randint(1000, len(data) - 1000)  # é¿å…æŸåæ–‡ä»¶å¤´
                data[pos] = random.randint(0, 255)
            dst.write(data)
        
        print(f"Generated corrupted test files in: {truncated_file.parent}")
    
    def calculate_md5(self, file_path):
        """è®¡ç®—æ–‡ä»¶MD5æ ¡éªŒå’Œ"""
        hash_md5 = hashlib.md5()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()
    
    def save_checksum(self, filename, checksum):
        """ä¿å­˜æ–‡ä»¶æ ¡éªŒå’Œ"""
        checksum_file = self.output_dir / "checksums.md5"
        with open(checksum_file, "a") as f:
            f.write(f"{checksum}  {filename}\n")

if __name__ == "__main__":
    generator = TestDataGenerator("test_data/standard")
    generator.generate_h264_test_files()
    generator.generate_corrupted_files()
```

## 7. æµ‹è¯•æ‰§è¡Œå’ŒæŠ¥å‘Š

### 7.1 æµ‹è¯•æ‰§è¡Œæµç¨‹
```bash
#!/bin/bash
# tools/run_all_tests.sh

set -e

echo "=== Plugin H264 Complete Test Suite ==="
echo "Starting comprehensive test execution..."

# 1. ç¯å¢ƒéªŒè¯
echo "Step 1: Validating test environment..."
python tools/validate_test_environment.py
if [ $? -ne 0 ]; then
    echo "âŒ Environment validation failed"
    exit 1
fi

# 2. æµ‹è¯•æ•°æ®å‡†å¤‡
echo "Step 2: Preparing test data..."
python tools/generate_test_data.py
python tools/verify_checksums.py

# 3. ç¼–è¯‘æµ‹è¯•
echo "Step 3: Building test suite..."
mkdir -p build_test && cd build_test
cmake -DCMAKE_BUILD_TYPE=Debug -DENABLE_TESTING=ON -DENABLE_COVERAGE=ON ..
make -j$(nproc)

# 4. æ‰§è¡Œæµ‹è¯•å¥—ä»¶
echo "Step 4: Running test suites..."

# åŠŸèƒ½æµ‹è¯• (P0 - å¿…é¡»å…¨éƒ¨é€šè¿‡)
echo "  4.1 Running P0 (Critical) tests..."
ctest --label-regex "P0" --output-on-failure
P0_RESULT=$?

# æ€§èƒ½æµ‹è¯• (P1 - é‡è¦)
echo "  4.2 Running performance tests..."
ctest --label-regex "PERF" --output-on-failure
PERF_RESULT=$?

# å…¼å®¹æ€§æµ‹è¯•
echo "  4.3 Running compatibility tests..."
ctest --label-regex "COMPAT" --output-on-failure
COMPAT_RESULT=$?

# å¯é æ€§æµ‹è¯•  
echo "  4.4 Running reliability tests..."
ctest --label-regex "RELIABILITY" --output-on-failure
RELIABILITY_RESULT=$?

# 5. ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
echo "Step 5: Generating test reports..."
lcov --capture --directory . --output-file coverage.info
lcov --remove coverage.info '/usr/*' --output-file coverage.info
lcov --list coverage.info

python ../tools/generate_test_report.py \
    --results ./Testing/*/Test.xml \
    --coverage ./coverage.info \
    --output ../test_report.html

# 6. ç»“æœæ±‡æ€»
echo "=== Test Results Summary ==="
echo "P0 Critical Tests: $([ $P0_RESULT -eq 0 ] && echo "âœ… PASSED" || echo "âŒ FAILED")"
echo "Performance Tests: $([ $PERF_RESULT -eq 0 ] && echo "âœ… PASSED" || echo "âš ï¸ CHECK REQUIRED")"
echo "Compatibility Tests: $([ $COMPAT_RESULT -eq 0 ] && echo "âœ… PASSED" || echo "âš ï¸ CHECK REQUIRED")"
echo "Reliability Tests: $([ $RELIABILITY_RESULT -eq 0 ] && echo "âœ… PASSED" || echo "âš ï¸ CHECK REQUIRED")"

# 7. è´¨é‡é—¨ç¦æ£€æŸ¥
if [ $P0_RESULT -ne 0 ]; then
    echo "âŒ QUALITY GATE FAILED: P0 tests must pass"
    exit 1
fi

echo "âœ… Test suite completed successfully"
echo "ğŸ“Š Full report available at: test_report.html"
```

---

## æ€»ç»“

æœ¬æµ‹è¯•ç”¨ä¾‹è®¾è®¡æ–‡æ¡£åŸºäºå®Œæ•´çš„æŠ€æœ¯éªŒè¯ç»“æœï¼Œæä¾›äº†å…¨é¢ã€å¯æ‰§è¡Œçš„æµ‹è¯•ç”¨ä¾‹è§„èŒƒã€‚ä¸»è¦ç‰¹ç‚¹ï¼š

### ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿
1. **éªŒè¯é©±åŠ¨**: æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹éƒ½åŸºäºå®é™…æŠ€æœ¯éªŒè¯ç»“æœ
2. **å…¨é¢è¦†ç›–**: åŠŸèƒ½ã€æ€§èƒ½ã€å…¼å®¹æ€§ã€å¯é æ€§å››ä¸ªç»´åº¦å®Œæ•´è¦†ç›–
3. **å¯æ‰§è¡Œæ€§**: æä¾›å®Œæ•´çš„å®ç°ç¤ºä¾‹å’Œæ‰§è¡Œè„šæœ¬
4. **å¯ç»´æŠ¤æ€§**: æ ‡å‡†åŒ–çš„æµ‹è¯•æ•°æ®å’Œå·¥å…·é“¾

### ğŸ“Š æµ‹è¯•è¦†ç›–ç»Ÿè®¡
- **åŠŸèƒ½æµ‹è¯•ç”¨ä¾‹**: 25+ ä¸ªæ ¸å¿ƒæµ‹è¯•åœºæ™¯
- **æ€§èƒ½æµ‹è¯•ç”¨ä¾‹**: 10+ ä¸ªåŸºå‡†å’Œå‹åŠ›æµ‹è¯•
- **å…¼å®¹æ€§æµ‹è¯•ç”¨ä¾‹**: 15+ ä¸ªè·¨å¹³å°å’Œæ ¼å¼æµ‹è¯•  
- **å¯é æ€§æµ‹è¯•ç”¨ä¾‹**: 8+ ä¸ªå¼‚å¸¸å’Œå‹åŠ›æµ‹è¯•

### ğŸ”§ è‡ªåŠ¨åŒ–ç¨‹åº¦
- **è‡ªåŠ¨åŒ–ç‡**: 90%+ æµ‹è¯•ç”¨ä¾‹å¯è‡ªåŠ¨æ‰§è¡Œ
- **CI/CDé›†æˆ**: å®Œæ•´çš„æŒç»­é›†æˆæµç¨‹
- **æŠ¥å‘Šç”Ÿæˆ**: è‡ªåŠ¨åŒ–æµ‹è¯•æŠ¥å‘Šå’Œè´¨é‡åˆ†æ

è¿™å°†ç¡®ä¿H.264æ’ä»¶å¼€å‘è¿‡ç¨‹ä¸­çš„æŒç»­è´¨é‡ä¿è¯å’Œæœ€ç»ˆäº§å“çš„é«˜å¯é æ€§ã€‚