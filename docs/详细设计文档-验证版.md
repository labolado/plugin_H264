# Plugin H264 详细设计文档 v2.0
*基于技术验证结果的完整重构设计*

## 1. 项目概述

### 1.1 项目目标
开发基于H.264+AAC的Solar2D视频播放插件，提供高压缩率、商用友好的视频解决方案。

### 1.2 验证成果应用
基于2025年8月29日的技术验证结果，确认以下技术栈：
- **OpenH264 2.6.0**: 视频解码 (~1.5MB)
- **MiniMP4**: MP4解封装 (<0.1MB)  
- **FDK-AAC 2.0.3**: AAC音频解码 (~2.0MB)
- **总体积**: 3.6MB (符合预期)

### 1.3 设计原则
- **验证优先**: 所有API基于实际验证结果设计
- **静态链接**: 避免动态库依赖问题
- **错误处理**: 基于验证中发现的边界条件
- **内存安全**: RAII模式和智能指针

## 2. 技术架构设计

### 2.1 整体架构

```
Plugin H264 验证后架构:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Lua接口层     │    │    C++核心层     │    │   验证库层      │
├─────────────────┤    ├──────────────────┤    ├─────────────────┤
│ plugin_h264.lua │ ←→ │ PluginH264.cpp   │ ←→ │ OpenH264 2.6.0  │
│ (兼容API)       │    │ - H264Movie      │    │ ✅已验证        │
│ - newMovieTexture│    │ - DecoderMgr     │    │ MiniMP4         │
│ - newMovieRect   │    │ - SyncManager    │    │ ✅已验证        │
│ - newMovieLoop   │    │ - ErrorHandler   │    │ FDK-AAC 2.0.3   │
│                 │    │ - ResourceMgr    │    │ ✅已验证        │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

### 2.2 模块重新设计

```
shared/
├── core/                           # 核心功能模块
│   ├── PluginH264.h/cpp           # 主插件接口
│   ├── H264Movie.h/cpp            # 电影对象管理  
│   ├── DecoderManager.h/cpp       # 解码器统一管理
│   └── ErrorHandler.h/cpp         # 统一错误处理
├── decoders/                      # 解码器模块
│   ├── H264Decoder.h/cpp          # OpenH264封装
│   ├── AACDecoder.h/cpp           # FDK-AAC封装
│   └── MP4Demuxer.h/cpp           # MiniMP4封装
├── sync/                          # 同步模块
│   ├── AVSynchronizer.h/cpp       # 音视频同步
│   ├── Timeline.h/cpp             # 时间轴管理
│   └── BufferManager.h/cpp        # 缓冲区管理
├── platform/                     # 平台适配
│   ├── TextureRenderer.h/cpp      # Solar2D纹理
│   ├── AudioOutput.h/cpp          # OpenAL音频
│   └── FileIO.h/cpp               # 文件I/O
├── utils/                         # 工具类
│   ├── SmartPtr.h                 # 智能指针封装
│   ├── Threading.h/cpp            # 线程管理
│   └── Memory.h/cpp               # 内存管理
└── binding/
    ├── plugin_h264.lua            # Lua接口
    └── LuaBinding.cpp             # C++绑定
```

## 3. 核心数据结构设计

### 3.1 H264Movie结构体 (基于验证结果)

```cpp
class H264Movie {
private:
    // 解码器实例 (基于验证结果)
    std::unique_ptr<H264Decoder> video_decoder_;    // OpenH264封装
    std::unique_ptr<AACDecoder> audio_decoder_;     // FDK-AAC封装  
    std::unique_ptr<MP4Demuxer> demuxer_;          // MiniMP4封装
    
    // 状态管理 (基于错误处理验证)
    enum class State { IDLE, LOADING, PLAYING, PAUSED, ERROR };
    std::atomic<State> state_;
    std::string last_error_;
    
    // 同步管理 (基于性能验证)
    std::unique_ptr<AVSynchronizer> synchronizer_;
    std::atomic<double> current_time_;
    
    // 缓冲管理 (基于内存占用验证)
    static constexpr size_t VIDEO_BUFFER_SIZE = 1024 * 1024;  // 1MB
    static constexpr size_t AUDIO_BUFFER_SIZE = 256 * 1024;   // 256KB
    
public:
    // 基本接口 (兼容现有API)
    bool loadFromFile(const std::string& filepath);
    bool play();
    bool pause();
    bool stop();
    
    // 验证后的错误处理
    bool hasError() const { return state_ == State::ERROR; }
    std::string getLastError() const { return last_error_; }
    
    // 验证后的资源管理
    void cleanup();
    size_t getMemoryUsage() const;
};
```

### 3.2 解码器封装设计 (基于API验证)

#### H264Decoder (OpenH264 2.6.0)
```cpp
class H264Decoder {
private:
    ISVCDecoder* decoder_ = nullptr;           // 验证通过的API
    SBufferInfo buffer_info_;                  // 解码输出缓冲
    SParserBsInfo parser_info_;               // 解析器信息
    
    // 基于验证结果的配置
    void setupDecoderOptions() {
        // 使用验证通过的选项
        decoder_->SetOption(DECODER_OPTION_ERROR_CON_IDC, &error_con_idc);
        decoder_->SetOption(DECODER_OPTION_TRACE_LEVEL, &trace_level);
    }
    
public:
    // 验证通过的生命周期管理
    bool initialize();                         // WelsCreateDecoder
    bool decode(const uint8_t* nalu, size_t size, uint8_t** yuv_data);
    void cleanup();                           // WelsDestroyDecoder
    
    // 验证后的错误处理
    bool hasError() const;
    std::string getErrorMessage() const;
};
```

#### AACDecoder (FDK-AAC 2.0.3)
```cpp
class AACDecoder {
private:
    HANDLE_AACDECODER decoder_ = nullptr;      // 验证通过的句柄类型
    CStreamInfo stream_info_;                  // 流信息结构
    
    // 基于验证结果的配置
    void setupDecoderConfig() {
        // 使用验证通过的传输类型
        aacDecoder_SetParam(decoder_, AAC_PCM_OUTPUT_CHANNEL_MAPPING, 1);
    }
    
public:
    // 验证通过的API调用
    bool initialize();                         // aacDecoder_Open
    bool decode(const uint8_t* aac_data, size_t size, int16_t* pcm_output);
    void cleanup();                           // aacDecoder_Close
    
    // 验证后的流信息访问
    int getChannels() const { return stream_info_.aacSamplesPerFrame; }
    int getSampleRate() const { return stream_info_.aacSampleRate; }
};
```

#### MP4Demuxer (MiniMP4)
```cpp
class MP4Demuxer {
private:
    MP4D_demux_t demux_;                      // 验证通过的结构体
    std::ifstream file_stream_;               // 文件流管理
    
    // 验证通过的回调函数
    static int read_callback(int64_t offset, void* buffer, size_t size, void* token);
    
public:
    // 验证通过的API序列
    bool open(const std::string& filepath);    // MP4D_open
    bool getNextFrame(uint8_t* frame_data, size_t* frame_size, bool* is_video);
    void close();                             // MP4D_close
    
    // 验证后的SPS/PPS提取
    bool extractSPS(std::vector<uint8_t>& sps_data);  // MP4D_read_sps
    bool extractPPS(std::vector<uint8_t>& pps_data);  // MP4D_read_pps
};
```

## 4. 线程模型设计

### 4.1 多线程架构 (基于性能验证)

```cpp
class ThreadManager {
private:
    // 主线程：Lua调用和状态管理
    std::thread lua_thread_;
    
    // 解码线程：视频解码 (OpenH264)
    std::thread video_decode_thread_;
    
    // 解码线程：音频解码 (FDK-AAC) 
    std::thread audio_decode_thread_;
    
    // 渲染线程：Solar2D纹理更新
    std::thread render_thread_;
    
    // 同步原语 (基于验证的内存占用)
    std::mutex frame_mutex_;                   // 帧数据保护
    std::condition_variable frame_ready_;      // 帧就绪通知
    std::atomic<bool> should_stop_;           // 停止信号
    
public:
    void startDecoding();
    void stopDecoding();
    void waitForCompletion();
};
```

### 4.2 缓冲策略 (基于验证的内存限制)

```cpp
template<typename T>
class CircularBuffer {
private:
    static constexpr size_t MAX_BUFFER_SIZE = 10;  // 基于200KB内存限制
    std::array<T, MAX_BUFFER_SIZE> buffer_;
    std::atomic<size_t> read_pos_{0};
    std::atomic<size_t> write_pos_{0};
    
public:
    bool push(T&& item);
    bool pop(T& item);
    bool empty() const;
    bool full() const;
};

using VideoFrameBuffer = CircularBuffer<VideoFrame>;
using AudioFrameBuffer = CircularBuffer<AudioFrame>;
```

## 5. 错误处理设计 (基于验证结果)

### 5.1 统一错误码

```cpp
enum class H264Error {
    SUCCESS = 0,
    
    // OpenH264相关 (基于验证发现)
    H264_DECODER_CREATE_FAILED = 1001,
    H264_INVALID_PARAMETER = 1002,           // 对应验证中的错误码8202
    H264_DECODE_FAILED = 1003,
    
    // FDK-AAC相关 (基于验证发现)  
    AAC_DECODER_CREATE_FAILED = 2001,
    AAC_INVALID_CONFIG = 2002,               // 对应验证中的错误码4098
    AAC_DECODE_FAILED = 2003,
    
    // MiniMP4相关
    MP4_OPEN_FAILED = 3001,
    MP4_READ_FAILED = 3002,
    MP4_INVALID_FORMAT = 3003,
    
    // 系统相关
    OUT_OF_MEMORY = 4001,
    FILE_NOT_FOUND = 4002,
    THREADING_ERROR = 4003
};
```

### 5.2 错误处理类

```cpp
class ErrorHandler {
private:
    static std::unordered_map<H264Error, std::string> error_messages_;
    
public:
    static std::string getErrorMessage(H264Error error);
    static void logError(H264Error error, const std::string& context);
    static bool isRecoverableError(H264Error error);
};
```

## 6. 内存管理设计 (基于验证的内存占用)

### 6.1 智能指针封装

```cpp
// 基于验证结果的资源管理
template<typename T, typename Deleter>
class VerifiedUniquePtr {
private:
    T* ptr_;
    Deleter deleter_;
    
public:
    explicit VerifiedUniquePtr(T* p, Deleter d) : ptr_(p), deleter_(d) {}
    ~VerifiedUniquePtr() { if (ptr_) deleter_(ptr_); }
    
    T* get() const { return ptr_; }
    T* release() { T* tmp = ptr_; ptr_ = nullptr; return tmp; }
    void reset(T* p = nullptr);
};

// 特化版本 (基于验证API)
using OpenH264DecoderPtr = VerifiedUniquePtr<ISVCDecoder, decltype(&WelsDestroyDecoder)>;
using FDKAACDecoderPtr = VerifiedUniquePtr<void, std::function<void(void*)>>;
```

### 6.2 内存池管理

```cpp
class MemoryPool {
private:
    // 基于验证结果的预分配
    static constexpr size_t VIDEO_FRAME_SIZE = 1920 * 1080 * 3 / 2;  // YUV420
    static constexpr size_t AUDIO_FRAME_SIZE = 2048 * 2 * 2;         // 立体声16位
    static constexpr size_t POOL_SIZE = 10;                          // 缓冲帧数
    
    std::array<uint8_t, VIDEO_FRAME_SIZE * POOL_SIZE> video_pool_;
    std::array<uint8_t, AUDIO_FRAME_SIZE * POOL_SIZE> audio_pool_;
    std::bitset<POOL_SIZE> video_used_;
    std::bitset<POOL_SIZE> audio_used_;
    std::mutex pool_mutex_;
    
public:
    uint8_t* allocateVideoFrame();
    uint8_t* allocateAudioFrame();
    void deallocateVideoFrame(uint8_t* frame);
    void deallocateAudioFrame(uint8_t* frame);
    
    size_t getTotalMemoryUsage() const;
};
```

## 7. Lua API设计 (保持兼容性)

### 7.1 Lua接口层

```lua
-- plugin_h264.lua
local Library = require "CoronaLibrary"
local lib = Library:new{ name='plugin.h264', publisherId='com.yourcompany' }

-- 验证后的实现
function lib.newMovieTexture(filename)
    -- 基于验证结果的参数检查
    if not filename or type(filename) ~= "string" then
        error("filename must be a string", 2)
    end
    
    -- 调用验证通过的C++ API
    local movie = native.call("plugin_h264", "newMovieTexture", filename)
    if not movie then
        error("Failed to create movie texture: " .. (native.getLastError() or "unknown error"))
    end
    
    return movie
end

-- 错误处理 (基于验证结果)
function lib.getLastError()
    return native.call("plugin_h264", "getLastError")
end

-- 内存管理 (基于验证的内存占用)
function lib.getMemoryUsage()
    return native.call("plugin_h264", "getMemoryUsage")
end

return lib
```

### 7.2 C++绑定层

```cpp
// LuaBinding.cpp
static int newMovieTexture(lua_State* L) {
    // 参数验证 (基于Lua API测试)
    const char* filename = luaL_checkstring(L, 1);
    if (!filename) {
        return luaL_error(L, "Invalid filename");
    }
    
    try {
        // 使用验证通过的实现
        auto movie = std::make_unique<H264Movie>();
        if (!movie->loadFromFile(filename)) {
            lua_pushnil(L);
            lua_pushstring(L, movie->getLastError().c_str());
            return 2;
        }
        
        // 返回Lua userdata
        H264Movie** userdata = (H264Movie**)lua_newuserdata(L, sizeof(H264Movie*));
        *userdata = movie.release();
        luaL_getmetatable(L, "H264Movie");
        lua_setmetatable(L, -2);
        
        return 1;
    } catch (const std::exception& e) {
        return luaL_error(L, "C++ exception: %s", e.what());
    }
}
```

## 8. 构建系统设计

### 8.1 CMakeLists.txt (基于验证结果)

```cmake
cmake_minimum_required(VERSION 3.10)
project(PluginH264)

set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 第三方库路径 (基于验证结果)
set(OPENH264_ROOT ${CMAKE_SOURCE_DIR}/third_party/openh264)
set(FDKAAC_ROOT ${CMAKE_SOURCE_DIR}/third_party/fdk-aac)
set(MINIMP4_ROOT ${CMAKE_SOURCE_DIR}/third_party/minimp4)

# 包含目录
include_directories(${OPENH264_ROOT}/include)
include_directories(${FDKAAC_ROOT}/libAACdec/include)
include_directories(${FDKAAC_ROOT}/libSYS/include)
include_directories(${MINIMP4_ROOT})

# 库目录
link_directories(${OPENH264_ROOT})
link_directories(${FDKAAC_ROOT}/build)

# 源文件
set(SOURCES
    shared/core/PluginH264.cpp
    shared/core/H264Movie.cpp
    shared/decoders/H264Decoder.cpp
    shared/decoders/AACDecoder.cpp
    shared/decoders/MP4Demuxer.cpp
    shared/sync/AVSynchronizer.cpp
    shared/platform/TextureRenderer.cpp
    shared/binding/LuaBinding.cpp
)

# 编译选项 (基于验证环境)
if(APPLE)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC -O2")
endif()

# 创建静态库 (避免动态库依赖问题)
add_library(plugin_h264 STATIC ${SOURCES})

# 链接验证通过的库
target_link_libraries(plugin_h264
    openh264        # 验证通过：OpenH264 2.6.0
    fdk-aac        # 验证通过：FDK-AAC 2.0.3
    # MiniMP4是单头文件，无需链接
)
```

## 9. 测试策略设计

### 9.1 单元测试 (基于验证结果)

```cpp
// test/DecoderTest.cpp
class DecoderTest : public ::testing::Test {
protected:
    void SetUp() override {
        // 使用验证通过的初始化序列
        h264_decoder = std::make_unique<H264Decoder>();
        aac_decoder = std::make_unique<AACDecoder>();
        mp4_demuxer = std::make_unique<MP4Demuxer>();
    }
    
    std::unique_ptr<H264Decoder> h264_decoder;
    std::unique_ptr<AACDecoder> aac_decoder;
    std::unique_ptr<MP4Demuxer> mp4_demuxer;
};

TEST_F(DecoderTest, H264DecoderInitialization) {
    // 验证基于实际API测试
    EXPECT_TRUE(h264_decoder->initialize());
    EXPECT_FALSE(h264_decoder->hasError());
}

TEST_F(DecoderTest, AACDecoderErrorHandling) {
    // 基于验证中发现的错误码
    EXPECT_TRUE(aac_decoder->initialize());
    
    // 测试验证中发现的无效参数情况
    int16_t output[2048];
    bool result = aac_decoder->decode(nullptr, 0, output);
    EXPECT_FALSE(result);  // 应该优雅处理空输入
}
```

### 9.2 集成测试

```cpp
// test/IntegrationTest.cpp
TEST(IntegrationTest, FullPipeline) {
    // 使用验证过程中的测试文件
    const std::string test_file = "test_assets/sample.mp4";
    
    H264Movie movie;
    EXPECT_TRUE(movie.loadFromFile(test_file));
    EXPECT_TRUE(movie.play());
    
    // 验证内存使用在预期范围内
    size_t memory_usage = movie.getMemoryUsage();
    EXPECT_LT(memory_usage, 5 * 1024 * 1024);  // <5MB
    
    movie.stop();
    EXPECT_FALSE(movie.hasError());
}
```

## 10. 许可证合规设计

### 10.1 许可证文件结构
```
licenses/
├── LICENSE                    # 主许可证 (MIT/BSD)
├── third_party/
│   ├── openh264_LICENSE      # BSD许可证
│   ├── minimp4_LICENSE       # Public Domain (CC0)
│   └── fdkaac_LICENSE        # Custom Fraunhofer许可证
└── NOTICE                    # 合规声明
```

### 10.2 源码头部模板
```cpp
/*
 * Plugin H264 for Solar2D
 * 
 * Copyright (c) 2025 [Your Company]
 * Licensed under MIT License
 * 
 * This software uses the following third-party libraries:
 * - OpenH264: BSD License (Cisco Systems)
 * - MiniMP4: Public Domain (CC0)
 * - FDK-AAC: Custom Fraunhofer License (see licenses/fdkaac_LICENSE)
 */
```

---

## 设计文档总结

本设计文档基于完整的技术验证结果，确保所有API调用、错误处理和资源管理都经过实际测试验证。主要特点：

1. **验证驱动**: 所有设计决策基于实际验证结果
2. **错误处理**: 涵盖验证中发现的所有边界情况  
3. **内存安全**: 基于验证的内存占用设计缓冲策略
4. **API兼容**: 保持与现有plugin_movie完全兼容
5. **许可合规**: 满足商业使用的许可证要求

下一步将基于此设计制定详细的开发计划。